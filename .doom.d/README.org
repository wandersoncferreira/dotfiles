#+TITLE: Emacs configuration
#+AUTHOR: Wanderson Ferreira
#+EMAIL: wand@hey.com
#+LANGUAGE: en
#+PROPERTY: header-args :emacs-lisp :tangle "~/.doom.d/config.el" :comments link
#+STARTUP: showall noinlineimages

[[https://imgs.xkcd.com/comics/cautionary.png]]

Emacs changes how you _think_ about computers.

I believe software should be malleable and allow users to tinker and create
something completely unpredictable by the creators of the original software.
Emacs is one of the few systems that allow us to do this.

Talk to your kids about Emacs... before somebody else does.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* Summary :TOC_3_gh:
- [[#general][General]]
  - [[#scratch-buffer][Scratch buffer]]
  - [[#disabled-major-modes][Disabled major modes]]
  - [[#enable-the-disabled-commands][Enable the disabled commands]]
- [[#editing][Editing]]
  - [[#iedit][iEdit]]
  - [[#auxiliary-functions][Auxiliary Functions]]
  - [[#bindings][Bindings]]
  - [[#abbreviations][Abbreviations]]
    - [[#auxiliary-functions-1][Auxiliary Functions]]
    - [[#bindings-1][Bindings]]
- [[#search][Search]]
- [[#spelling][Spelling]]
- [[#project][Project]]
  - [[#projectile][Projectile]]
- [[#dired][Dired]]
  - [[#functions][Functions]]
- [[#completion][Completion]]
  - [[#vertico][Vertico]]
  - [[#company][Company]]
- [[#appearance][Appearance]]
  - [[#fonts][Fonts]]
  - [[#modeline][Modeline]]
  - [[#extra-functions][Extra functions]]
- [[#window][Window]]
  - [[#moving-between-windows][Moving between windows]]
  - [[#scroll][Scroll]]
  - [[#better-split][Better split]]
  - [[#workspace][Workspace]]
    - [[#change-modeline-workspace-name][Change modeline workspace name]]
- [[#programming][Programming]]
  - [[#lsp][LSP]]
  - [[#emacs-lisp][Emacs Lisp]]
    - [[#appearance-1][Appearance]]
    - [[#taming-parenthesis][Taming Parenthesis]]
    - [[#test-frameworks][Test frameworks]]
  - [[#clojure][Clojure]]
    - [[#clojure-mode][Clojure Mode]]
    - [[#cider][CIDER]]
    - [[#clojure-refactor][Clojure Refactor]]
    - [[#snippets][Snippets]]
    - [[#parenthesis][Parenthesis]]
    - [[#docs][Docs]]
    - [[#functions-1][Functions]]
  - [[#java][Java]]
    - [[#appearance-2][Appearance]]
  - [[#typescript][TypeScript]]
- [[#org-mode][Org mode]]
  - [[#defaults][Defaults]]
  -  [[#blog][Blog]]
  -  [[#roam][Roam]]
    -  [[#ui][UI]]
    -  [[#bibtex][Bibtex]]
  - [[#org-ref][Org-ref]]
  - [[#download][Download]]
  - [[#spaced-repetition][Spaced Repetition]]
  - [[#latex-fragments][Latex fragments]]
  - [[#notes-on-pdfs][Notes on PDFs]]
  - [[#easy-templates][Easy Templates]]
- [[#version-control][Version Control]]
  - [[#magit][Magit]]
  - [[#forge][Forge]]
  - [[#github][Github]]
    - [[#bug-reference][Bug Reference]]
    - [[#notifications][Notifications]]
  - [[#code-review][Code Review]]
- [[#key-bindings][Key bindings]]
  - [[#registers][Registers]]
  - [[#general-1][General]]
  - [[#parenthesis-1][Parenthesis]]
- [[#shell][Shell]]
  - [[#eshell][Eshell]]
- [[#macos-specifics][MacOS specifics]]
  - [[#homebrew][Homebrew]]
- [[#apps][Apps]]
  - [[#gif][Gif]]
  - [[#plantuml][PlantUML]]
  - [[#keyfreq][Keyfreq]]
  - [[#vlf][VLF]]
  - [[#irc][IRC]]
    - [[#twitch][Twitch]]
  - [[#ledger][Ledger]]
    - [[#auxiliary-functions-2][Auxiliary Functions]]
- [[#authentication][Authentication]]
  - [[#auxiliary-functions-3][Auxiliary functions]]
- [[#patches][Patches]]
  - [[#doom][Doom]]
- [[#work][Work]]
  - [[#app-sauce][App Sauce]]
  - [[#reify-health][Reify Health]]
  - [[#cisco][Cisco]]

* General

Define name and email.
#+begin_src emacs-lisp
(setq user-full-name "Wanderson Ferreira"
      user-mail-address "wand@hey.com")
#+end_src

The line spacing configuration is something new to me, but makes emacs looks a
lot nicer!
#+begin_src emacs-lisp
(setq scroll-margin 2
      line-spacing 3)
#+end_src

#+begin_src emacs-lisp
(setq enable-local-variables t
      messages-buffer-max-lines 10000

      load-prefer-newer t
      show-help-function nil
      read-process-output-max (* 1024 1024))
#+end_src

Remove byte compilation warnings related to old =cl= library.
#+begin_src emacs-lisp
(setq byte-compile-warnings '(cl-functions))
#+end_src

Learned this in my first week of Emacs with Magnars: real emacs knights don't
use shift to mark things
#+begin_src emacs-lisp
(setq shift-select-mode nil)
#+end_src

Uniquify buffer names dependent on file name. Emacs's traditional method for
making buffer names unique is to add <2>, <3>, <4>, .... to the end of the
buffer names.

#+begin_src emacs-lisp
(use-package! uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets
        uniquify-separator " * "
        uniquify-after-kill-buffer-p t
        uniquify-strip-common-suffix t
        uniquify-ignore-buffers-re "^\\*"))
#+end_src

** Scratch buffer

#+begin_src emacs-lisp
(setq doom-scratch-initial-major-mode 'emacs-lisp-mode
      initial-major-mode 'emacs-lisp-mode)
#+end_src

** Disabled major modes

highlighting current line is very distracting to me.
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'global-hl-line-mode)
#+end_src

Paredit >> Smartparens IMHO
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'smartparens-global-mode)
#+end_src

** Enable the disabled commands

#+begin_src emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+end_src

* Editing

UTF-8
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

Delete selection
#+begin_src emacs-lisp
(delete-selection-mode +1)
#+end_src

Group digits to ease reading large numbers
#+begin_src emacs-lisp
(use-package! digit-groups
  :config
  (digit-groups-global-mode t))
#+end_src

#+begin_quote
In recent times, a vicious beast known only as the "Unicode troll" has risen
from the abyss, wielding his fearsome tool, the Unicode homoglyph. Looking
nearly identical to common ASCII characters, these homoglyphs hide in code,
lying in wait for an unsuspecting programmer to devour whole without warning.

Don't be the next victim. Enable =unicode-troll-stopper-mode= and force these
vicious beasts from the shadows in which they lurk.
#+end_quote

#+begin_src emacs-lisp
(use-package! unicode-troll-stopper
  :hook (prog-mode-hook . unicode-troll-stopper-mode))
#+end_src


Kill additional white spaces when joining lines
#+begin_src emacs-lisp
(defadvice kill-line (before kill-line-autoreindent activate)
  "Kill excess whitespace when joining lines.
If the next line is joined to the current line, kill the extra indent whitespace."
  (when (and (eolp) (not (bobp)))
    (save-excursion
      (forward-char 1)
      (just-one-space 1))))
#+end_src

Copy and cut single line when no region available.
#+begin_src emacs-lisp
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Single line killed")
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no activate region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+end_src

** iEdit

#+begin_src emacs-lisp
;; when you hit Ctrl+;, all occurrences of the symbol under the cursor (or
;; current selection) are highlighted, and any changes you make on one of them
;; will be automatically applied to all others.
(use-package! iedit
  :defer
  :config
  (set-face-background 'iedit-occurrence "saddle brown")
  :bind
  ("C-." . iedit-mode))
#+end_src

** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/point-to-register ()
  "Store cursor position in a register."
  (interactive)
  (point-to-register 8)
  (message "Point set"))

 (defun bk/jump-to-register ()
  "Switch between current pos and stored pos."
  (interactive)
  (let ((tmp (point-marker)))
    (jump-to-register 8)
    (set-register 8 tmp)))

(defun bk/kill-inner-word ()
  "Equivalent to ciw in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))

(defun bk/copy-whole-line ()
  "Copies a line without refard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol)))))

(defun bk/zap-to-char-backward (arg char)
  (interactive "p\ncZap up to char backward: ")
  (save-excursion
    (zap-up-to-char -1 char)))
#+end_src

** Bindings
#+begin_src emacs-lisp
(map!
 "C-c r p" #'bk/point-to-register
 "C-c r j" #'bk/jump-to-register
 "C-c k w" #'bk/kill-inner-word
 "C-c k f" #'zap-up-to-char
 "C-c k b" #'bk/zap-to-char-backward
 "C-c y l" #'bk/copy-whole-line)
#+end_src

** Abbreviations

Use single abbrev-table for multiple modes
#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

Default global table
#+begin_src emacs-lisp
(define-abbrev-table 'global-abbrev-table
  '(
    ("reuslt" "result" nil 0)
    ("requier" "require" nil 0)
    ))
#+end_src

*** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/add-region-local-abbrev (start end)
  "Go from START to END and add the selected text to a local abbrev."
  (interactive "r")
  (if (use-region-p)
      (let ((num-words (count-words-region start end)))
        (add-mode-abbrev num-words)
        (deactivate-mark))
    (message "No selected region!")))

(defun bk/add-region-global-abbrev (start end)
  "Go from START to END and add the selected text to global abbrev."
  (interactive "r")
  (if (use-region-p)
      (let ((num-words (count-words-region start end)))
        (add-abbrev global-abbrev-table "Global" num-words)
        (deactivate-mark))
    (message "No selected region!")))
#+end_src

*** Bindings

#+begin_src emacs-lisp
(map!
 "C-x a l" #'bk/add-region-local-abbrev
 "C-x a g" #'bk/add-region-global-abbrev)
#+end_src

* Search

Workaround to make =deadgrep= consider hidden folders and symlinks
#+begin_src emacs-lisp
(require 'deadgrep)

(defun deadgrep--include-args (rg-args)
  (push "--hidden" rg-args) ;; consider hidden folders/files
  (push "--follow" rg-args) ;; follow symlink
  )

(advice-add 'deadgrep--arguments :filter-return #'deadgrep--include-args)
#+end_src

* Spelling

I am using the fast spell checkers =spell-fu= instead of =flyspell=. Something I
miss from flyspell is the =flyspell-correct-previous= which kept the point in
the same place but fixed the previous error.

If you use Universal Argument =C-u= with the following function you will be
prompted to Add or Fix the previous error at point.
#+begin_src emacs-lisp
(defun bk/spell-fu-correct-previous (arg)
  (interactive "P")
  (save-excursion
    (if arg
        (progn
          (+spell/previous-error)
          (let* ((word (word-at-point))
                 (res (y-or-n-p (format "Add %s at point? " word))))
            (if res
                (+spell/add-word)
              (+spell/correct))))
      (progn
        (+spell/previous-error)
        (+spell/correct)))))
#+end_src

Add the binding to the default =C-;=
#+begin_src emacs-lisp
(map!
 "C-;" #'bk/spell-fu-correct-previous)
#+end_src

I type in portuguese and english most of the time, therefore would be handy if Emacs could tell which one is it in the current buffer.
#+begin_src emacs-lisp
(use-package! guess-language
  :config
  (setq guess-language-languages '(en pt)
        guess-language-langcodes
        '((en . ("en_US" "English"))
          (pt . ("pt_BR" "Portuguese")))))
#+end_src

Langtool is very useful to not native English speakers. You can download the jar from [[curl -o langtool.zip https://languagetool.org/download/LanguageTool-stable.zip && unzip langtool.zip][here]]
#+begin_src emacs-lisp
(setq langtool-language-tool-jar "~/Downloads/LanguageTool-5.5/languagetool-commandline.jar")
#+end_src

Change dictionary of Ispell
#+begin_src emacs-lisp
(defun bk/dict-pt ()
  "Change to pt-BR dictionary."
  (interactive)
  (ispell-change-dictionary "pt_BR"))

(defun bk/dict-en ()
  "Change to en dictionary."
  (interactive)
  (ispell-change-dictionary "en"))
#+end_src

* Project

** Projectile

Disable cache
#+begin_src emacs-lisp
(setq projectile-enable-caching nil)
#+end_src

Direct projectile to look for code in a specific folder.
#+begin_src emacs-lisp
(setq projectile-project-search-path '("~/code"))
#+end_src

Remove the modeline indicator of Projectile.
#+begin_src emacs-lisp
(use-package! projectile
  :delight projectile-mode)
#+end_src

Toggle between implementation and tests using the super key.
#+begin_src emacs-lisp
(map!
 "s-t" #'projectile-toggle-between-implementation-and-test)
#+end_src

* Dired

Change the default listing command in Dired to show file size in
"human-readable" format.
#+begin_src emacs-lisp
(setq dired-listing-switches "-alh")
#+end_src

Dired jump is indispensable nowadays
#+begin_src emacs-lisp
(map! "C-x C-j" #'dired-jump)
#+end_src

** Functions

Sort dired listings with directories first
#+begin_src emacs-lisp
(defun bk/dired-directories-first ()
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2)
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(advice-add 'dired-readin :after #'bk/dired-directories-first)
#+end_src

fix the cursor positioning when we hit =C-<= and =C->= to beg/end of buffer.
#+begin_src emacs-lisp
(defun bk/dired-back-to-start-of-files ()
  (interactive)
  (backward-char (- (current-column) 2)))

(defun bk/dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (next-line 2)
  (bk/dired-back-to-start-of-files))

(defun bk/dired-back-to-bottom ()
  (interactive)
  (end-of-buffer)
  (next-line -1)
  (bk/dired-back-to-start-of-files))

(map! :map dired-mode-map
      "M-<" #'bk/dired-back-to-top
      "M->" #'bk/dired-back-to-bottom)
#+end_src

* Completion

#+begin_quote
Completion is a feature that fills in the rest of a name starting from an
abbreviation for it. Completion works by comparing the user’s input against a
list of valid names and determining how much of the name is determined uniquely
by what the user has typed. -- Emacs Manual
#+end_quote


** Vertico

VERTical Interactive COmpletion provides a performance and minimalistic vertical
completion UI based on the default completion system. The main focus of Vertico
is to provide a UI which behaves _correctly_ under all circumstances.

There are a couple of extensions to Vertico that will be useful to me.
#+begin_src emacs-lisp
(after! vertico
  (map! "M-r" #'vertico-repeat))
#+end_src

Provide quick keys navigation in Vertico buffer. Same behavior as the package Avy.
#+begin_src emacs-lisp
(after! vertico
  (map! :map vertico-map
        "M-q" #'vertico-quick-insert
        "C-q" #'vertico-quick-exit))
#+end_src

Nice! This is even better than the Avy-like behavior IMHO. The way it works is
by prefixing every candidate found with a number and then you can choose it
using prefix arguments. For example, if you want to choose the 5th candidate
type =M-5 RET=.
#+begin_src emacs-lisp
(after! vertico
  (vertico-indexed-mode t))
#+end_src

Enable keybinding to activate Vertico Grid.
#+begin_src emacs-lisp
(after! vertico
  (map! :map vertico-map
        "M-G" #'vertico-grid-mode))
#+end_src

** Company
#+begin_src emacs-lisp
(use-package! company
  :init
  (setq company-idle-delay 0.1
        company-show-quick-access t
        company-icon-size 20)
  :config
  (set-company-backend! 'prog-mode nil)
  (set-company-backend! 'prog-mode
    '(:separate company-capf company-files company-dabbrev-code company-yasnippet))
  (define-key company-active-map [(control) (meta) ?s] 'company-search-candidates)
  (define-key company-active-map "\C-s" 'company-filter-candidates))
#+end_src

Disable company mode in org-buffers.
#+begin_src emacs-lisp
(after! company
  (setq company-global-modes
        '(not erc-mode
              circe-mode
              message-mode
              help-mode
              org-mode)))
#+end_src

* Appearance

Doom comes with some nice themes. For now, I've been using Zenburn most of the
time.

#+begin_src emacs-lisp
(setq doom-theme 'kaolin-dark
      doom-themes-treemacs-theme "all-the-icons"
      fill-column 180
      display-line-numbers-type nil
      confirm-kill-emacs nil
      indent-tabs-mode nil)

(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (outline-minor-mode -1)))
#+end_src

Highlight numbers
#+begin_src emacs-lisp
(use-package! highlight-numbers
  :hook (prog-mode-hook . highlight-numbers-mode))
#+end_src

Change theme based on time of the day.
#+begin_src emacs-lisp
(use-package! theme-changer
  :init
  (setq calendar-location-name "Sao Paulo, BR"
        calendar-latitude -23.550520
        calendar-longitude -46.633308)
  :config
  (change-theme 'kaolin-light 'kaolin-dark))
#+end_src

Show column number in the modeline.
#+begin_src emacs-lisp
(column-number-mode +1)
#+end_src

Show size indication
#+begin_src emacs-lisp
(size-indication-mode t)
#+end_src

** Fonts

Set default fonts in Doom
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Monaco" :size 14)
      doom-variable-pitch-font (font-spec :family "Roboto"
                                          :style "Regular"
                                          :size 14
                                          :weight 'regular)
      doom-unicode-font (font-spec :family "Apple Color Emoji"))
#+end_src

Use proportional fonts
#+begin_src emacs-lisp
(use-package! mixed-pitch
  :hook (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-face 'variable-pitch))
#+end_src

** Modeline

I am not using any Doom modeline as I prefer the default one. Therefore I need
to use some package to clean the modeline from all the indicators of minor modes
enabled.

#+begin_src emacs-lisp
(use-package! delight
  :config
  (delight '(;; general
             (eldoc-mode nil eldoc)
             (gcmh-mode nil gcmh)
             (which-key-mode nil which-key)
             (better-jumper-local-mode nil better-jumper)
             (company-mode nil company)
             (paredit-mode nil paredit)
             (git-gutter-mode nil git-gutter)
             (abbrev-mode nil abbrev)
             (annotate-mode nil annotate)

             ;; programming
             (lsp-lens-mode nil lsp-lens)
             (whitespace-mode nil whitespace)
             (ws-butler-mode nil ws-butler)
             (yas-minor-mode nil yasnippet)

             (mixed-pitch-mode nil mixed-pitch)

             ;; org
             (visual-line-mode nil simple)
             (org-roam-mode nil org-roam)
             (org-indent-mode nil org-indent)
             (org-fancy-priorities-mode nil org-fancy-priorities)
             (writegood-mode nil writegood-mode)
             (org-roam-bibtex-mode nil org-roam-bibtex)

             ;; clojure
             (clj-refactor-mode nil clj-refactor)
             (symbol-focus-mode nil symbol-focus)
             (dtrt-indent-mode nil dtrt-indent))))
#+end_src

** Extra functions

In some moods I like to have some level of transparency while coding.
#+begin_src emacs-lisp
(defun bk/toggle-transparency ()
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                    ((numberp (cdr alpha)) (cdr alpha))
                    ((numberp (cadr alpha)) (cadr alpha)))
              100)
         90
       100))))
#+end_src

Print what face is under the cursor
#+begin_src emacs-lisp
(defun what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property pos 'read-face-name)
                  (get-char-property pos 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+end_src

Hacky way to avoid saving faces in custom.el file.
#+begin_src emacs-lisp
(defun custom-save-faces ()
  "No-op"
  (interactive))
#+end_src

Customization to specific themes
#+begin_src emacs-lisp
(defun bk/default-theme ()
  "Change highlight colors when using the default white theme."
  (set-face-attribute 'lazy-highlight nil :background "khaki1")
  (set-face-attribute 'isearch nil :background "khaki1")
  (set-face-attribute 'region nil :background "khaki1"))

(defun bk/slate-gray-theme ()
  "Slate Grat"
  (interactive)
  (set-background-color "DarkSlateGray")
  (set-face-background 'mode-line "Wheat")
  (set-face-foreground 'mode-line "DarkSlateGray")
  (set-foreground-color "Wheat"))

(defun bk/alect-themes-customizations ()
  (custom-set-faces
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(font-lock-variable-name-face ((t (:foreground "#6a621b"))))
   '(ivy-current-match ((t (:extend t :background "#b0d0f3" :foreground "#101010" :weight bold))))
   '(lsp-lsp-flycheck-info-unnecessary-face ((t (:foreground "#2020cc" :underline (:color "dark orange" :style wave)))) t)))

(defun bk/high-contrast-customizations ()
  (custom-set-faces
   '(mode-line ((t (:background "Gray75" :foreground "Black"))))
   '(mode-line-buffer-id ((t (:background "Gray75" :foreground "blue4"))))
   '(mode-line-mousable ((t (:background "Gray75" :foreground "firebrick"))))
   '(mode-line-mousable-minor-mode ((t (:background "Gray75" :foreground "green4"))))))

(defun bk/default-black-customizations ()
  "Customizations to be used with default black theme in Doom Emacs"
  (custom-set-faces
   '(doom-modeline-buffer-path ((t (:foreground "black" :weight bold))))
   '(doom-modeline-project-dir ((t (:foreground "black" :weight bold))))
   '(doom-modeline-buffer-modified ((t (:foreground "Blue" :weight bold))))
   '(success ((t (:foreground "ForestGreen" :weight bold))))))
#+end_src

* Window
Recenter on next-error
#+begin_src emacs-lisp
(add-hook! 'next-error-hook #'recenter)
#+end_src

** Moving between windows

Use shift arrows to move between windows.
#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src

However, Org mode requires a little workaround to make shift arrow movements to
work.
#+begin_src emacs-lisp
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src

** Scroll

Scrolling whole screens seems so weird to me. I like a predefined number of
lines. 8 to be exact.
#+begin_src emacs-lisp
(defun bk/scroll-up ()
 (interactive)
  (scroll-up-command 8))

(defun bk/scroll-down ()
 (interactive)
  (scroll-down-command 8))

(map!
 "C-v" #'bk/scroll-up
 "M-v" #'bk/scroll-down)
#+end_src

** Better split

When you split the buffer in any direction, move the cursor there and show the
previous buffer.
#+begin_src emacs-lisp
(defun bk/vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun bk/hsplit-last-buffer ()
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))
#+end_src

Overwrite the default split bindings
#+begin_src emacs-lisp
(map! "C-x 2" #'bk/vsplit-last-buffer
      "C-x 3" #'bk/hsplit-last-buffer)
#+end_src

** Workspace

Using a dedicated set of buffers to specific kind of work has been interesting.
There are some annoyances along the way but we can fix it.

I want to switch to a new workspace automatically if I change projectile
projects.
#+begin_src emacs-lisp
(setq +workspaces-on-switch-project-behavior t)
#+end_src

Also delete the workspace automatically if there is no buffers associated anymore
#+begin_src emacs-lisp
(setq persp-autokill-persp-when-removed-last-buffer t)
#+end_src

*** Change modeline workspace name

Overwrite the Doom function that writes to the modeline.
#+begin_src emacs-lisp
(setq persp-lighter
      '(:eval
        (format
         (propertize
          " #%.15s"
          'face (let ((persp (get-current-persp)))
                  (if persp
                      (if (persp-contain-buffer-p (current-buffer) persp)
                          'persp-face-lighter-default
                        'persp-face-lighter-buffer-not-in-persp)
                    'persp-face-lighter-nil-persp)))
         (safe-persp-name (get-current-persp)))))
#+end_src

* Programming

** LSP

#+begin_src emacs-lisp
(use-package! lsp-mode
  :config
  (add-to-list 'lsp-file-watch-ignored-directories "classes")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\minio\\'")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\terraform\\'")
  ;; fix "bug"
  (advice-remove #'lsp #'+lsp-dont-prompt-to-install-servers-maybe-a)
  
  (advice-add #'lsp-rename :after (lambda (&rest _) (projectile-save-project-buffers))))
#+end_src

Disable the reference marks in LSP.
#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-lens-enable nil))
#+end_src

#+begin_src emacs-lisp
 (use-package! lsp-treemacs
  :config
  (setq lsp-treemacs-error-list-current-project-only t))

(use-package! treemacs-all-the-icons
  :after treemacs)
#+end_src

** Emacs Lisp

*** Appearance

I don't like the too colorful buffers. So, removing the rainbow delimiter mode.
#+begin_src emacs-lisp
(after! elisp-mode
  (remove-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode))
#+end_src

*** Taming Parenthesis

You will definitely hate Lisp if you don't understand structural editing.
#+begin_src emacs-lisp
(after! elisp-mode
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode))
#+end_src

*** Test frameworks

Buttercup (Behavior Driven Emacs Lisp Testing) framework has one annoyance when
you run the test suite: it moves the cursor from the point to the end of the
test file. This =advice= is a workaround to keep the point where it was:
#+begin_src emacs-lisp
(use-package! buttercup
  :config
  (define-advice buttercup--run-suites (:around (orig-fun &rest args))
    "Keep the cursor at-point after running test suite with buttercup."
    (setq save-point (point))
    (unwind-protect
        (apply orig-fun args)
      (goto-char save-point))))
#+end_src

** Clojure

Very lucky to be working with Clojure for so many years. I've learned a lot
about FP and other languages in the process and so many great people in the
community.

*** Clojure Mode

#+begin_src emacs-lisp
(use-package! clojure-mode
  :init
  (setq clojure-thread-all-but-last t)
  :config
  (cljr-add-keybindings-with-prefix "C-c C-m")
  (remove-hook 'clojure-mode-hook #'rainbow-delimiters-mode))
#+end_src

Sometimes I forget to start the REPL and I try to use a CIDER command. This
warning message is very helpful.
#+begin_src emacs-lisp
(defun bk/nrepl-warn-when-not-connected ()
  (interactive)
  (message "Oops! You'are not connected to an nREPL server."))

(map! :map clojure-mode-map
      "C-x C-e" #'bk/nrepl-warn-when-not-connected
      "C-c C-k" #'bk/nrepl-warn-when-not-connected
      "C-c C-z" #'bk/nrepl-warn-when-not-connected

      ;; tests
      "C-c k t" #'kaocha-runner-run-test-at-point
      "C-c k r" #'kaocha-runner-run-tests
      "C-c k a" #'kaocha-runner-run-all-tests
      "C-c k w" #'kaocha-runner-show-warnings
      "C-c k h" #'kaocha-runner-hide-windows)
#+end_src

*** CIDER

#+begin_src emacs-lisp
(use-package! cider
  :after clojure-mode
  :init
  (setq cider-jdk-src-paths '("~/Downloads/clojure-1.10.3-sources" "~/Downloads/jvm11/source")
        cider-clojure-cli-command "~/code/dotfiles/clojure/clojure-bin-enriched"
        ;; cider-show-error-buffer t
        ;; cider-save-file-on-load t
        ;; cider-eldoc-display-for-symbol-at-point nil ;; use lsp
        ;; cider-repl-use-pretty-printing nil
        ;; cider-redirect-server-output-to-repl t
        ;; clojure-toplevel-inside-comment-form t
        )
  :config
  ;; (add-hook! 'cider-test-report-mode-hook 'toggle-truncate-lines)
  ;; (add-hook 'cider-mode-hook
  ;;           (lambda ()
  ;;             ;; let's give LSP a chance.
  ;;             (remove-hook 'completion-at-point-functions
  ;;                          #'cider-complete-at-point)))

  ;; (add-to-list
  ;;  'display-buffer-alist
  ;;  `(, (rx bos (or "*cider-repl"
  ;;                  "*nrepl-server"
  ;;                  "*cider-test-report*"
  ;;                  "*cider-error"
  ;;                  "*cider-result"))
  ;;      (display-buffer-reuse-window
  ;;       display-buffer-in-direction)
  ;;      (direction . right)
  ;;      (window .root)
  ;;      (dedicated . nil)
  ;;      (window-width . 0.25)))
  )
#+end_src

Working with =+workspace= enabled in DOOM makes a new workspace to be created
for each project. However, if you start a CIDER REPL in any workspace the
special buffers are not bound to the current workspace. Let's fix this
#+begin_src emacs-lisp
;; include cider buffer into current workspace
(add-hook 'cider-repl-mode-hook
          (lambda ()
            (persp-add-buffer (current-buffer) (get-current-persp)
                              nil nil)))

;; include test report buffer to current perspective too
(add-hook 'cider-test-report-mode-hook
          (lambda ()
            (persp-add-buffer (current-buffer) (get-current-persp)
                              nil nil)))
#+end_src

**** Patch to Hotload dependencies

Experimental configuration to hotload refactor using Pomegranate from Cemerick
and integrating it in clj-refactor.

#+begin_src emacs-lisp
(after! cider-mode

  (setq cljr-hotload-dependencies t)

  (defun bk/send-to-repl (sexp eval ns)
    (ignore eval)
    (cider-switch-to-repl-buffer ns)
    (goto-char cider-repl-input-start-mark)
    (delete-region (point) (point-max))
    (save-excursion
      (insert sexp)
      (when (equal (char-before) ?\n)
        (delete-char -1))
      (cider-repl--send-input t))
    (delete-region (point) (point-max)))

  (defun bk/pomegranate-dep (dep)
    (concat
     (format
      "%s"
      `(use '[cemerick.pomegranate :only (add-dependencies)]))
     (s-replace-all
      `(("\\." . ".")
        ("mydep" . ,dep))
      (format
       "%S"
       `(add-dependencies :coordinates '[mydep]
                          :repositories (merge cemerick.pomegranate.aether/maven-central
                                               {"clojars" "https://clojars.org/repo"}))))))

  (defun cljr-hotload-dependency (artifact version &optional dep ns)
    (ignore dep)
    (bk/send-to-repl
     (bk/pomegranate-dep (format "[%s \"%s\"]" artifact version))
     t ns))

  (defun cljr--add-project-dependency (artifact version)
    (let* ((project-file (cljr--project-file))
           (deps (cljr--project-with-deps-p project-file)))
      (cljr--update-file project-file
        (goto-char (point-min))
        (if deps
            (cljr--insert-into-clj-dependencies artifact version)
          (cljr--insert-into-leiningen-dependencies artifact version))
        (cljr--post-command-message "Added %s version %s as a project dependency" artifact version))
      (when cljr-hotload-dependencies
        (if deps
            (back-to-indentation)
          (paredit-backward-down))
        (cljr-hotload-dependency artifact version)))))

#+end_src

*** Clojure Refactor

#+begin_src emacs-lisp
(use-package! clj-refactor
  :after clojure-mode
  :config
  (setq cljr-warn-on-eval nil
        cljr-eagerly-build-asts-on-startup t
        cljr-add-ns-to-blank-clj-files t
        cljr-magic-require-namespaces
        '(("io" . "clojure.java.io")
          ("set" . "clojure.set")
          ("str" . "clojure.string")
          ("walk" . "clojure.walk")
          ("zip" . "clojure.zip")
          ("m" . "muuntaja.core"))))
#+end_src

Magnars created this amazing code called =symbol-focus= to help refactoring
activity in Clojure. The package allow us to easily edit pieces of code in
isolation.
#+begin_src emacs-lisp
(use-package! symbol-focus
  :load-path "~/.doom.d/sources/symbol-focus"
  :config
  (add-hook 'prog-mode-hook #'symbol-focus-mode)

  (map! :map symbol-focus-mode-map
      "C-s-b" #'sf/back
      "C-s-n" #'sf/next
      "C-s-p" #'sf/prev
      "C-s-r" #'sf/reset))
#+end_src

*** Snippets

I am trying to rely more on snippets, they are life savers.
#+begin_src emacs-lisp
(use-package! clojure-snippets)
#+end_src

*** Parenthesis

#+begin_src emacs-lisp
(after! clojure-mode
  (add-hook 'clojure-mode-hook 'enable-paredit-mode)
  (add-hook 'cider-mode-hook 'enable-paredit-mode)
  (add-hook 'cider-repl-mode-hook 'enable-paredit-mode))
#+end_src

*** Docs

Let's enable Clojure docset for Dash.
#+begin_src emacs-lisp
;; run `dash-docs-install-docset' to get it if new installation
(set-docsets! 'clojure-mode "Clojure")
#+end_src

*** Functions

Execute clojure code and return the result as string
#+begin_src emacs-lisp
(defun bk/sync-eval-to-string (s)
  "Execute clojure code S and return the result as string"
  (let* ((x (concat "(do (clojure.core/in-ns '"
                    (cider-current-ns)
                    ") " s ")"))
         (dict (cider-nrepl-sync-request:eval x))
         (e (nrepl-dict-get dict "err"))
         (v (nrepl-dict-get dict "value")))
    (if e
        (user-error! e)
      v)))
#+end_src

Find the PID of the current process
#+begin_src emacs-lisp
(defun bk/clojure-pid ()
  "Find PID of current clojure process."
  (interactive)
  (message
   (bk/sync-eval-to-string
    "(-> (java.lang.management.ManagementFactory/getRuntimeMXBean)
         (.getName)
         (clojure.string/split #\"@\")
         (first))")))
#+end_src

Clear all cider buffers
#+begin_src emacs-lisp
(defun bk/cider/clear-all-buffers ()
  (interactive)
  (let ((inhibit-read-only 't))
    (dolist (repl (cider-repls))
      (with-current-buffer repl
        (cider-repl--clear-region (point-min) cider-repl-prompt-start-mark)
        (cider-repl--clear-region cider-repl-output-start cider-repl-output-end)
        (when (< (point) cider-repl-input-start-mark)
          (goto-char cider-repl-input-start-mark))))))
#+end_src

Delete all cider REPL buffers
#+begin_src emacs-lisp
(defun bk/cider/kill-all-buffers ()
  (interactive)
  (dolist (b (buffer-list))
    (when (string-prefix-p "*cider-repl" (buffer-name b))
      (kill-buffer (buffer-name b)))))
#+end_src

** Java
LSP is very good to develop in Java.

#+begin_src emacs-lisp
(use-package! lsp-java
  :init
  (setq lsp-java-format-settings-profile "GoogleStyle"
        lsp-java-format-settings-url "https://raw.githubusercontent.com/google/styleguide/gh-pages/eclipse-java-google-style.xml"
        lsp-java-save-actions-organize-imports t)
  :config
  (add-hook! 'java-mode-hook (electric-pair-mode +1))
  (add-hook! 'java-mode-hook (subword-mode +1)))
#+end_src

*** Appearance

No colorful window either
#+begin_src emacs-lisp
(after! cc-mode
  (remove-hook 'java-mode-hook #'rainbow-delimiters-mode))
#+end_src

** TypeScript

This auto formatting is not good :/

#+begin_src emacs-lisp
(add-hook 'typescript-mode-hook #'format-all-mode)
(setq-hook! 'typescript-mode-hook +format-with-lsp nil)
#+end_src

* Org mode

*You life in plain text*

#+begin_quote
A GNU Emacs major mode for keeping notes, authoring documents, computational
notebooks, literate programming, maintaining to-do lists, planning projects, and
more — in a fast and effective plain text system.
#+end_quote

** Defaults

#+begin_src emacs-lisp
(use-package! org
  :init
  (setq org-return-follows-link t
        org-directory "~/org/"
        org-fontify-quote-and-verse-blocks nil
        org-fontify-whole-heading-line nil
        org-hide-leading-stars nil
        org-startup-indented nil
        org-agenda-files (list "~/agenda/todo.org"))
  :config
  (remove-hook 'org-mode-hook #'org-superstar-mode))
#+end_src

**  Blog

Using hugo to blog from time to time.

#+begin_src emacs-lisp
(setq org-hugo-base-dir "~/wandersoncferreira.github.io"
      org-hugo-section "items"
      org-hugo-front-matter-format "yaml")
#+end_src

**  Roam

Define the roam directory:
#+begin_src emacs-lisp
(use-package! org-roam
  :config
  (setq org-roam-directory "/Users/wferreir/roam-v2"
        org-roam-dailies-directory "/Users/wferreir/roam-v2/dailies"))
#+end_src

Not sure why I need this tbh
#+begin_src emacs-lisp
(use-package! websocket
  :after org-roam)
#+end_src

***  UI

Roam UI is amazing project to explore your graph nodes interactively in the browser.
#+begin_src emacs-lisp
(use-package! org-roam-ui
  :after org-roam
  :defer t
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

***  Bibtex

Allow me to manage my bibliographical notes using Org Roam
#+begin_src emacs-lisp
(use-package! org-roam-bibtex
  :after org-roam
  :init
  (setq bibtex-completion-bibliography '("~/roam-v2/references.bib")
        bibtex-completion-library-path "~/roam-v2/resources")
  :config
  (org-roam-bibtex-mode))
#+end_src

** Org-ref
makes it easy to insert citations, cross-references, indexes, and glossaries as
hyper-functional links into org files.

#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :commands
  (org-ref-cite-hydra/body
   org-ref-bibtex-hydra/body)
  :config
  (setq org-ref-default-bibliography '("~/roam-v2/references.bib")
        org-ref-show-broken-links nil
        org-ref-pdf-directory "~/roam-v2/resources")
  :bind
  (:map org-mode-map
   (("C-c ]" . org-ref-insert-link))))
#+end_src

** Download

Let you screenshot and yank images from the web into your org buffer.
#+begin_src emacs-lisp
(use-package! org-download
  :after org
  :bind
  (:map org-mode-map
   (("s-Y" . org-download-screenshot)
    ("s-y" . org-download-yank))))
#+end_src

** Spaced Repetition

We can produce cards to perform spaced repetition study technique
#+begin_src emacs-lisp
(use-package org-fc
  :load-path "~/.doom.d/sources/org-fc"
  :custom (org-fc-directories '("~/roam-v2"))
  :config
  (add-to-list 'org-fc-custom-contexts
               '(security-cards . (:filter (tag "security"))))
  (add-to-list 'org-fc-custom-contexts
               '(comptia-QA . (:filter (tag "comptia-qa")))))
#+end_src

** Latex fragments

#+begin_src emacs-lisp
(use-package! org-fragtog
  :after org
  :hook (org-mode . org-fragtog-mode))
#+end_src

** Notes on PDFs

Enable pdf-tools
#+begin_src emacs-lisp
(pdf-tools-install)
#+end_src


#+begin_src emacs-lisp
(use-package! org-noter
  :after (:any org pdf-view)
  :config (setq org-noter-hide-other nil
                org-noter-notes-search-path (list "~/roam-v2")))

(use-package! org-pdftools
  :hook (org-load . org-pdftools-setup-link))

(use-package! org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

** Easy Templates

The "Easy Templates" as often is the standard way in Emacs to handle inline code
blocks when writing in literate programming style.

You can find all the different templates available by =C-h v org-structure-template-alist=.

Let's define an Elisp template as I am using it soo often.
#+begin_src emacs-lisp
(require 'org-tempo)
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
#+end_src

* Version Control

** Magit

#+begin_src emacs-lisp
(use-package! magit
  :init
  (setq magit-diff-refine-hunk t
        magit-log-show-gpg-status t
        magit-commit-show-diff nil
        magit-display-buffer-function (lambda (buf) (display-buffer buf '(display-buffer-same-window)))
        magit-section-initial-visibility-alist
        `((untracked . show)
          (unstaged . show)
          (unpushed . show)
          (unpulled . show)
          (stashes . show)))
  :config
  (add-to-list 'magit-no-confirm 'stage-all-changes))
#+end_src

** Forge

I hack-ed my way out of Forge to create Draft PullRequests too
#+begin_src emacs-lisp
(defun bk/forge--add-draft (alist)
  "Add draft to ALIST."
  (append alist '((draft . "t"))))

(defun bk/post-draft-pull-request ()
  "Submit the post that is being edit in the current buffer as a draft."
  (interactive)
  (advice-add 'forge--topic-parse-buffer
              :filter-return #'bk/forge--add-draft)
  (condition-case err
      (forge-post-submit)
    (t
     (advice-remove 'forge--topic-parse-buffer #'bk/forge--add-draft)
     (signal (car err) (cdr err))))
  (advice-remove 'forge--topic-parse-buffer #'bk/forge--add-draft))
#+end_src

** Github
*** Bug Reference

#+begin_src emacs-lisp
(use-package! bug-reference-github
  :config
  (add-hook 'prog-mode-hook 'bug-reference-github-set-url-format))
#+end_src

*** Notifications

#+begin_src emacs-lisp
(use-package gh-notify
  :load-path "~/.doom.d/sources/gh-notify"
  :config
  (setq gh-notify-redraw-on-visit t))
#+end_src

** Code Review

I'm the maintainer of this package
#+begin_src emacs-lisp
(use-package code-review
  :load-path "~/code/code-review"
  :defer t
  :commands (code-review-start
             code-review-forge-pr-at-point)
  :config
  (map! :map forge-post-mode-map
      "C-c C-d" #'bk/post-draft-pull-request

      :map forge-topic-mode-map
      "C-c r" #'code-review-forge-pr-at-point))
#+end_src

* Key bindings

Minor default changes
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.4
      tab-always-indent 'complete)
#+end_src

Disabling =C-x p= because I really like to pop to mark with these keys.
#+begin_src emacs-lisp
(map! "C-x p" nil)
#+end_src

Enabling disabled commands
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+end_src

** Registers

#+begin_src emacs-lisp
(set-register ?l '(file . "/Users/wferreir/ledger"))
(set-register ?b '(file . "/Users/wferreir/code/dotfiles/macos/Brewfile"))
(set-register ?c '(file . "/Users/wferreir/code/dotfiles/.doom.d/README.org"))
#+end_src

** General

#+begin_src emacs-lisp
(map!
 ;; C-x keys
 "C-x b" #'+vertico/switch-workspace-buffer
 "C-x p" #'pop-to-mark-command
 "C-x k" #'kill-this-buffer
 "C-x C-m" #'execute-extended-command

 ;; super keys
 "s-'" #'cycle-quotes
 "s-s" #'deadgrep
 "s-g" #'gh-notify
 "s-p" #'+popup/toggle

 ;; F-* keys
 "<f5>" #'deadgrep
 "<f9>" #'gif-screencast-start-or-stop
 "<f12>" #'pomidor

 ;; C-c keys
 "C-c d" #'crux-duplicate-current-line-or-region
 "C-c c SPC" #'rotate-layout

 ;; editor
 "M-p" #'jump-char-backward
 "M-n" #'jump-char-forward
 "M-i" #'change-inner
 "M-u" #'fix-word-upcase
 "M-l" #'fix-word-downcase
 "M-c" #'fix-word-capitalize
 "C-<up>" #'move-text-up
 "C-<down>" #'move-text-down

 ;; movement
 "C-:" #'avy-goto-char
 "M-g w" #'avy-goto-word-1

 ;; completion
 "C-." #'completion-at-point
 )
#+end_src

** Parenthesis

#+begin_src emacs-lisp
(map! :map paredit-mode-map
      "C-c ( n" #'paredit-add-to-next-list
      "C-c ( p" #'paredit-add-to-previous-list
      "M-s" nil ;; TODO splice needs a new place
      )
#+end_src

* Shell

** Eshell

These aliases follow me since the beginning of my Emacs experience
#+begin_src emacs-lisp
(require 'em-alias)
(add-hook 'eshell-mode-hook
          (lambda ()
            (eshell/alias "e" "find-file $1")
            (eshell/alias "ee" "find-file-other-window $1")))
#+end_src

Clean buffer with =C-l=
#+begin_src emacs-lisp
(defun eshell-clear-buffer ()
  "Clear the terminal buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))

(add-hook 'eshell-mode-hook
          (lambda ()
            (local-set-key (kbd "C-l") 'eshell-clear-buffer)))
#+end_src

* MacOS specifics

I prefer to change Command to =meta=.

#+begin_src emacs-lisp
(when IS-MAC
  (setq mac-command-modifier 'meta
        mac-option-modifier '(:ordinary super :button 2)))
#+end_src


** Homebrew

Sometimes I need to verify if a package is available in homebrew or not. Making
the query from Emacs has been useful.

#+begin_src emacs-lisp
(defun bk/brew-search ()
  "Search homebrew for a file to be installed."
  (interactive "")
  (let* ((query (read-string "Search in Homebrew: "))
         (res (shell-command-to-string
               (format "brew search %s" query)))
         (res-list (-> res
                       (split-string "==> Formulae")
                       (-second-item)
                       (string-trim)
                       (split-string "\n")))
         (to-be-installed
          (completing-read
           "Install one of the packages: "
           res-list)))
    (when (not (string-empty-p to-be-installed))
      (async-shell-command
       (format "brew install %s" to-be-installed)))))
#+end_src

* Apps

I'm not sure how to classify something as an "app" inside Emacs. Perhaps they
are heavily dependent of external tools?

To be honest, most things in this section are here because I don't know a better
place to put it.

** Gif

I need to show off some Emacs work or feature and be able to record a small GIF
in seconds is perfect. During the development of my Emacs packages I've been
recording GIFs to reproduce feature behaviors to new users a lot.

#+begin_src emacs-lisp
(use-package! gif-screencast
  :config
  (setq gif-screencast-args '("-x")
        gif-screencast-cropping-program "mogrify"
        gif-screencast-capture-format "ppm"))
#+end_src


** PlantUML

Drawing diagrams to put some form to your system design ideas? Yeap!

#+begin_src emacs-lisp
(setq plantuml-jar-path "~/code/dotfiles/plantuml.jar")
#+end_src


** Keyfreq

Important to monitor your key usage in order to improve your editing skills in
the long run. More tips [[https://github.com/wandersoncferreira/vim-mindset-apply-emacs#general-tips][here]].

#+begin_src emacs-lisp
(use-package! keyfreq
  :init
  (setq keyfreq-excluded-commands
        '(self-insert-command
          org-self-insert-command))
  :config
  (keyfreq-mode +1)
  (keyfreq-autosave-mode +1))
#+end_src


** VLF

Help opening very large files.

#+begin_src emacs-lisp
(use-package! vlf
  :config
  (require 'vlf-setup)
  (custom-set-variables
   '(vlf-application 'dont-ask)))
#+end_src


** IRC

I like to communicate like its the 70's again.

#+begin_src emacs-lisp
(require 'erc)
(require 'erc-track)

(setq erc-server "irc.libera.chat"
      erc-nick "bartuka"
      erc-user-full-name "Wanderson Ferreira"
      erc-track-shorten-start 8
      erc-kill-buffer-on-part t
      erc-auto-query 'bury
      erc-prompt-for-password nil)
#+end_src

*** Twitch

I learned it was possible to connect to a Twitch chat via IRC>
#+begin_src emacs-lisp
(defun twitch-start-irc ()
  "Connect to Twitch IRC.
Get an oauth token from this website https://twitchapps.com/tmi/."
  (interactive)
  (let* ((host "irc.chat.twitch.tv")
         (user "bartuka_")
         (pwd (auth-source-pick-first-password
               :host host
               :user user)))
    (erc-tls :server host
             :port 6697
             :nick user
             :password pwd)))
#+end_src


** Ledger

Control your finances with Ledger-cli.

Activate the =ledger-mode= to every file called =ledger=
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\ledger\\'" . ledger-mode))
#+end_src

Some queries/reports that I usually follow in my ledger
#+begin_src emacs-lisp
(setq
 ledger-reports
 '(("netcash" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^assets:bank ^assets:crypto liabilities:card")
   ("sports" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:sports")
   ("doctor" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:doctor")
   ("apartamento-mae" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:mother")
   ("apartamento-misce" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:misce")
   ("eas-profit" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --invert --current bal ^expenses:eval ^income:eval")
   ("food" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:food")
   ("donation" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:donation")
   ("apartamento-morumbi" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:house")
   ("creta" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:car:creta ^equity:car:creta")
   ("networth" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank liabilities equity:apartment")
   ("spent-vs-earned" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger bal -X BRL --period=\"last 4 weeks\" ^Expenses ^Income --invert -S amount")
   ("budget" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank:checking:budget liabilities:card")
   ("taxes" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^expenses:taxes")
   ("bal" "%(binary) -f %(ledger-file) bal")
   ("reg" "%(binary) -f %(ledger-file) reg")
   ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
   ("account" "%(binary) -f %(ledger-file) reg %(account)")))
#+end_src

*** Auxiliary Functions

Copy last ledger entry
#+begin_src emacs-lisp
(defun bk/copy-ledger-entry ()
  (interactive)
  (save-excursion
    (backward-sentence)
    (let ((beg (point)))
      (forward-sentence)
      (kill-ring-save beg (point))))
  (yank))
#+end_src

Formatting the whole ledger buffer to keep time sorting.
#+begin_src emacs-lisp
(defun bk/clean-ledger ()
  "Bring back timeline structure to the whole file."
  (interactive)
  (if (eq major-mode 'ledger-mode)
      (let ((curr-line (line-number-at-pos)))
        (ledger-mode-clean-buffer)
        (line-move (- curr-line 1)))))
#+end_src

* Authentication

I rely on =auth-source= a lot to store my passwords. A =~/.authinfo.gpg= file is
a safe way to keep passwords stored for as long as you remember your GPG
password :')

The following piece of configuration was carefully crafted to be integrated with
MacOS key manager.

#+begin_src emacs-lisp
(require 'epa-file)
(require 'org-crypt)

(setq epg-gpg-program "gpg"
      org-tags-exclude-from-inheritance (quote ("crypt"))
      password-cache-expiry nil)

(after! auth-source
  (setq auth-sources (nreverse auth-sources)
        auth-source-cache-expiry nil
        auth-source-debug t))

(after! epa
  (set 'epg-pinentry-mode nil)
  (setq epa-file-encrypt-to '("wand@hey.com")))

(epa-file-enable)
(org-crypt-use-before-save-magic)
#+end_src

** Auxiliary functions

I also have a Bitwarden account to store things in the web. This function helps
me to get some useful data in the gpg file.

#+begin_src emacs-lisp
(defun bk/bitwarden ()
  "Get bitwarden."
  (interactive)
  (kill-new (auth-source-pick-first-password
             :host "bitwarden.app"
             :user "bartuka")))
#+end_src

* Patches

Sometimes I need to overwrite some implementation in a package.

** Doom

Overwrite the =load!= macro to consider GPG configuration files.
#+begin_src emacs-lisp
(defmacro load! (filename &optional path noerror)
  "Load a file relative to the current executing file (`load-file-name').

FILENAME is either a file path string or a form that should evaluate to such a
string at run time. PATH is where to look for the file (a string representing a
directory path). If omitted, the lookup is relative to either `load-file-name',
`byte-compile-current-file' or `buffer-file-name' (checked in that order).

If NOERROR is non-nil, don't throw an error if the file doesn't exist."
  (let* ((path (or path
                   (dir!)
                   (error "Could not detect path to look for '%s' in"
                          filename)))
         (file (if path
                   `(expand-file-name ,filename ,path)
                 filename)))
    `(if (string-match-p ".gpg$" ,file)
         (add-hook 'after-init-hook (lambda () (load-file ,file)))
       (condition-case-unless-debug e
           (let (file-name-handler-alist)
             (load ,file ,noerror 'nomessage))
         (doom-error (signal (car e) (cdr e)))
         (error (doom--handle-load-error e ,file ,path))))))
#+end_src

* Work

Every now and then I have to write some elisp code to help me in my work. I like
to keep them organized to keep at least some context to where/why the function
came to existence.

** App Sauce

First time I experimented with Git Worktrees in day to day work. Really liked
it. A git worktree + projectile + a dedicated clojure REPL connected == Great
experience!

#+begin_src emacs-lisp
(defun bk/create-worktree ()
  "Help development on multiple branches."
  (interactive)
  (let* ((root-proj (projectile-project-root))
         (proj-name (car (cdr (nreverse (split-string root-proj "/")))))
         (dest-dir (file-name-directory (directory-file-name root-proj)))
         (branch (ido-completing-read "Choose the branch: " (magit-list-local-branch-names)))
         (worktree-path (concat dest-dir proj-name "-wt-" branch)))
    (magit-worktree-checkout worktree-path branch)
    (projectile-find-file)))

(defun bk/delete-worktree ()
  "Delete worktree and all its open buffers."
  (interactive)
  (let ((worktree (ido-completing-read "Choose worktree: " (magit-list-worktrees))))
    (mapc (lambda (buffer)
            (with-current-buffer buffer
              (let ((worktree-name (file-name-base worktree)))
                (when (string-equal (projectile-project-name) worktree-name)
                  (kill-buffer buffer)))))
          (buffer-list))
    (projectile-remove-current-project-from-known-projects)
    (magit-worktree-delete worktree)))
#+end_src

** Reify Health

Basic functions to connect to Clojure REPL.
#+begin_src emacs-lisp
(defun reifyhealth/cider-connect ()
  "Connect into eSource."
  (interactive)
  (cider-connect-clj (list :host "localhost" :port 12344)))
#+end_src

Open my specific notes from work.
#+begin_src emacs-lisp
(defun reifyhealth ()
  "Open file notes from work."
  (interactive)
  (find-file "~/repos/reifyhealth/work.org"))
#+end_src

and we had to generate UUIDs to mock some tests every so often.
#+begin_src emacs-lisp
(defun bk/uuid ()
  "Create uuid and add to clipboard."
  (interactive)
  (kill-new (uuidgen-4)))
#+end_src

** Cisco

Good stuff.
#+begin_src emacs-lisp
(load! "+work-cisco.el.gpg")
#+end_src
