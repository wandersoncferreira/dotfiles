#+TITLE: Emacs configuration
#+AUTHOR: Wanderson Ferreira
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: fold

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* Summary :TOC_2_gh:
- [[#general][General]]
  - [[#scratch-buffer][Scratch buffer]]
  - [[#disabled-major-modes][Disabled major modes]]
- [[#editing][Editing]]
  - [[#iedit][iEdit]]
  - [[#auxiliary-functions][Auxiliary Functions]]
  - [[#bindings][Bindings]]
  - [[#abbreviations][Abbreviations]]
- [[#search][Search]]
- [[#spelling][Spelling]]
- [[#completion][Completion]]
  - [[#company][Company]]
- [[#appearance][Appearance]]
- [[#window][Window]]
  - [[#moving][Moving]]
  - [[#better-split][Better split]]
  - [[#workspace][Workspace]]
- [[#programming][Programming]]
  - [[#lsp][LSP]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#clojure][Clojure]]
  - [[#java][Java]]
  - [[#typescript][TypeScript]]
- [[#version-control][Version Control]]
  - [[#magit][Magit]]
  - [[#forge][Forge]]
  - [[#github][Github]]
  - [[#code-review][Code Review]]
- [[#key-bindings][Key bindings]]
  - [[#parenthesis][Parenthesis]]
- [[#shell][Shell]]
  - [[#eshell][Eshell]]
- [[#macos-specifics][MacOS specifics]]
  - [[#search-in-homebrew][Search in Homebrew]]
- [[#apps][Apps]]
  - [[#gif][Gif]]
  - [[#plantuml][PlantUML]]
  - [[#keyfreq][Keyfreq]]
  - [[#vlf][VLF]]
  - [[#irc][IRC]]
  - [[#ledger][Ledger]]
- [[#authentication][Authentication]]
  - [[#auxiliary-functions-1][Auxiliary functions]]
- [[#patches][Patches]]
  - [[#doom][Doom]]
- [[#work][Work]]
  - [[#app-sauce][App Sauce]]
  - [[#reify-health][Reify Health]]
  - [[#cisco][Cisco]]

* General

#+begin_src emacs-lisp
(setq user-full-name "Wanderson Ferreira"
      user-mail-address "wand@hey.com"

      byte-compile-warnings '(cl-functions)

      scroll-margin 2
      line-spacing 3

      enable-local-variables t
      messages-buffer-max-lines 10000

      load-prefer-newer t
      show-help-function nil
      read-process-output-max (* 1024 1024)
      dired-listing-switches "-ahl -v"

      projectile-enable-caching nil
      projectile-project-search-path '("~/code"))
#+end_src

** Scratch buffer

#+begin_src emacs-lisp
(setq doom-scratch-initial-major-mode 'emacs-lisp-mode
      initial-major-mode 'emacs-lisp-mode)
#+end_src

** Disabled major modes

highlighting current line is very distracting to me.
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'global-hl-line-mode)
#+end_src

Paredit >> Smartparens IMHO
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'smartparens-global-mode)
#+end_src

* Editing

UTF-8
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

Kill additional whitespaces when joining lines
#+begin_src emacs-lisp
(defadvice kill-line (before kill-line-autoreindent activate)
  "Kill excess whitespace when joining lines.
If the next line is joined to the current line, kill the extra indent whitespace."
  (when (and (eolp) (not (bobp)))
    (save-excursion
      (forward-char 1)
      (just-one-space 1))))
#+end_src

Copy and cut single line when no region available.
#+begin_src emacs-lisp
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Single line killed")
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no activate region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+end_src

** iEdit

#+begin_src emacs-lisp
;; when you hit Ctrl+;, all occurrences of the symbol under the cursor (or
;; current selection) are highlighted, and any changes you make on one of them
;; will be automatically applied to all others.
(use-package! iedit
  :defer
  :config
  (set-face-background 'iedit-occurrence "saddle brown")
  :bind
  ("C-;" . iedit-mode))
#+end_src

** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/point-to-register ()
  "Store cursor position in a register."
  (interactive)
  (point-to-register 8)
  (message "Point set"))

 (defun bk/jump-to-register ()
  "Switch between current pos and stored pos."
  (interactive)
  (let ((tmp (point-marker)))
    (jump-to-register 8)
    (set-register 8 tmp)))

(defun bk/kill-inner-word ()
  "Equivalent to ciw in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))

(defun bk/copy-whole-line ()
  "Copies a line without refard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol)))))

(defun bk/zap-to-char-backward (arg char)
  (interactive "p\ncZap up to char backward: ")
  (save-excursion
    (zap-up-to-char -1 char)))
#+end_src

** Bindings
#+begin_src emacs-lisp
(map!
 "C-c r p" #'bk/point-to-register
 "C-c r j" #'bk/jump-to-register
 "C-c k w" #'bk/kill-inner-word
 "C-c k f" #'zap-up-to-char
 "C-c k b" #'bk/zap-to-char-backward
 "C-c y l" #'bk/copy-whole-line)
#+end_src

** Abbreviations

Use single abbrev-table for multiple modes
#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

Default global table
#+begin_src emacs-lisp
(define-abbrev-table 'global-abbrev-table
  '(
    ("reuslt" "result" nil 0)
    ("requier" "require" nil 0)
    ))
#+end_src

*** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/add-region-local-abbrev (start end)
  "Go from START to END and add the selected text to a local abbrev."
  (interactive "r")
  (if (use-region-p)
      (let ((num-words (count-words-region start end)))
        (add-mode-abbrev num-words)
        (deactivate-mark))
    (message "No selected region!")))

(defun bk/add-region-global-abbrev (start end)
  "Go from START to END and add the selected text to global abbrev."
  (interactive "r")
  (if (use-region-p)
      (let ((num-words (count-words-region start end)))
        (add-abbrev global-abbrev-table "Global" num-words)
        (deactivate-mark))
    (message "No selected region!")))
#+end_src

*** Bindings

#+begin_src emacs-lisp
(map!
 "C-x a l" #'bk/add-region-local-abbrev
 "C-x a g" #'bk/add-region-global-abbrev)
#+end_src

* Search

Workaround to make =deadgrep= consider hidden folders and symlinks
#+begin_src emacs-lisp
(require 'deadgrep)

(defun deadgrep--include-args (rg-args)
  (push "--hidden" rg-args) ;; consider hidden folders/files
  (push "--follow" rg-args) ;; follow symlink
  )

(advice-add 'deadgrep--arguments :filter-return #'deadgrep--include-args)
#+end_src

* Spelling

Langtool is very useful to not native English speakers. You can download the jar from [[curl -o langtool.zip https://languagetool.org/download/LanguageTool-stable.zip && unzip langtool.zip][here]]
#+begin_src emacs-lisp
(setq langtool-language-tool-jar "~/Downloads/LanguageTool-5.5/languagetool-commandline.jar")
#+end_src

Change dictionary of Ispell
#+begin_src emacs-lisp
(defun bk/dict-pt ()
  "Change to pt-BR dictionary."
  (interactive)
  (ispell-change-dictionary "pt_BR"))

(defun bk/dict-en ()
  "Change to en dictionary."
  (ispell-change-dictionary "en"))
#+end_src

* Completion

** Company
#+begin_src emacs-lisp
(use-package! company
  :init
  (setq company-idle-delay 0.1
        company-show-quick-access t
        company-icon-size 20)
  :config
  (set-company-backend! 'prog-mode nil)
  (set-company-backend! 'prog-mode
    '(:separate company-capf company-files company-dabbrev-code company-yasnippet))
  (define-key company-active-map [(control) (meta) ?s] 'company-search-candidates)
  (define-key company-active-map "\C-s" 'company-filter-candidates))
#+end_src

* Appearance

Doom comes with some nice themes. For now, I've been using Zenburn most of the
time.

#+begin_src emacs-lisp
(setq doom-theme 'doom-zenburn)
#+end_src

* Window

Recenter on next-error
#+begin_src emacs-lisp
(add-hook! 'next-error-hook #'recenter)
#+end_src

** Moving

Use shift arrows to move between windows.
#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src

However, Org mode requires a little workaround to make shift arrow movements to
work.
#+begin_src emacs-lisp
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src

** Better split

When you split the buffer in any direction, move the cursor there and show the
previous buffer.
#+begin_src emacs-lisp
(defun bk/vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun bk/hsplit-last-buffer ()
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))
#+end_src

Overwrite the default split bindings
#+begin_src emacs-lisp
(map! "C-x 2" #'bk/vsplit-last-buffer
      "C-x 3" #'bk/hsplit-last-buffer)
#+end_src

** Workspace

Using a dedicated set of buffers to specific kind of work has been interesting.
There are some annoyances along the way but we can fix it.

I want to switch to a new workspace automatically if I change projectile
projects.
#+begin_src emacs-lisp
(setq +workspaces-on-switch-project-behavior t)
#+end_src

Also delete the workspace automatically if there is no buffers associated anymore
#+begin_src emacs-lisp
(setq persp-autokill-persp-when-removed-last-buffer t)
#+end_src

*** Change modeline workspace name

Overwrite the Doom function that writes to the modeline.
#+begin_src emacs-lisp
(after! persp
  (setq persp-lighter
        '(:eval
          (format
           (propertize
            " #%.10s"
            'face (let ((persp (get-current-persp)))
                    (if persp
                        (if (persp-contain-buffer-p (current-buffer) persp)
                            'persp-face-lighter-default
                          'persp-face-lighter-buffer-not-in-persp)
                      'persp-face-lighter-nil-persp)))
           (safe-persp-name (get-current-persp))))))
#+end_src

* Programming

** LSP

#+begin_src emacs-lisp
(use-package! lsp-mode
  :init
  (setq lsp-enable-file-watchers t
        lsp-enable-symbol-highlighting t
        lsp-eldoc-enable-hover t
        lsp-lens-enable t
        lsp-idle-delay 0.1
        lsp-headerline-breadcrumb-enable nil)
  :config
  (add-to-list 'lsp-file-watch-ignored-directories "classes")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\minio\\'")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\terraform\\'")

  (add-hook! 'lsp-before-open-hook
    (remove-hook! 'lsp-completion-mode-hook #'+lsp-init-company-backends-h))

  (advice-add #'lsp-rename :after (lambda (&rest _) (projectile-save-project-buffers))))
#+end_src

#+begin_src emacs-lisp
(use-package! lsp-ui
  :after lsp-mode
  :commands lsp-ui-mode
  :config
  (setq lsp-ui-doc-max-width 60
        lsp-ui-doc-position 'top
        lsp-ui-doc-delay 0.2
        lsp-ui-peek-list-width 60
        lsp-ui-peek-fontify 'always
        lsp-ui-sideline-show-code-actions nil))
#+end_src

#+begin_src emacs-lisp
 (use-package! lsp-treemacs
  :config
  (setq lsp-treemacs-error-list-current-project-only t))

(use-package! treemacs-all-the-icons
  :after treemacs)
#+end_src

** Emacs Lisp

*** Appearance

I don't like the too colorful buffers. So, removing the rainbow delimiter mode.
#+begin_src emacs-lisp
(after! elisp-mode
  (remove-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode))
#+end_src

*** Taming Parenthesis

You will definitely hate Lisp if you don't understand structural editing.
#+begin_src emacs-lisp
(after! elisp-mode
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode))
#+end_src

*** Test frameworks

Buttercup (Behavior Driven Emacs Lisp Testing) framework has one annoyance when
you run the test suite: it moves the cursor from the point to the end of the
test file. This =advice= is a workaround to keep the point where it was:
#+begin_src emacs-lisp
(use-package! buttercup
  :config
  (define-advice buttercup--run-suites (:around (orig-fun &rest args))
    "Keep the cursor at-point after running test suite with buttercup."
    (setq save-point (point))
    (unwind-protect
        (apply orig-fun args)
      (goto-char save-point))))
#+end_src

** Clojure

Very lucky to be working with Clojure for so many years. I've learned a lot
about FP and other languages in the process and so many great people in the
community.

*** Clojure Mode

#+begin_src emacs-lisp
(use-package! clojure-mode
  :init
  (setq clojure-thread-all-but-last t)
  :config
  (cljr-add-keybindings-with-prefix "C-c C-m")
  (remove-hook 'clojure-mode-hook #'rainbow-delimiters-mode))
#+end_src

Sometimes I forget to start the REPL and I try to use a CIDER command. This
warning message is very helpful.
#+begin_src emacs-lisp
(defun bk/nrepl-warn-when-not-connected ()
  (interactive)
  (message "Oops! You'are not connected to an nREPL server."))

(map! :map clojure-mode-map
      "C-x C-e" #'bk/nrepl-warn-when-not-connected
      "C-c C-k" #'bk/nrepl-warn-when-not-connected
      "C-c C-z" #'bk/nrepl-warn-when-not-connected

      ;; tests
      "C-c k t" #'kaocha-runner-run-test-at-point
      "C-c k r" #'kaocha-runner-run-tests
      "C-c k a" #'kaocha-runner-run-all-tests
      "C-c k w" #'kaocha-runner-show-warnings
      "C-c k h" #'kaocha-runner-hide-windows)
#+end_src

*** CIDER

#+begin_src emacs-lisp
(use-package! cider
  :after clojure-mode
  :init
  (setq cider-jdk-src-paths '("~/Downloads/clojure-1.10.3-sources" "~/Downloads/jvm11/source")
        cider-show-error-buffer t
        cider-save-file-on-load t
        cider-eldoc-display-for-symbol-at-point nil ;; use lsp
        cider-repl-use-pretty-printing nil
        cider-redirect-server-output-to-repl t
        clojure-toplevel-inside-comment-form t
        cider-clojure-cli-command "~/code/dotfiles/clojure/clojure-bin-enriched")
  :config
  (add-hook! 'cider-test-report-mode-hook 'toggle-truncate-lines)
  (add-hook 'cider-mode-hook
            (lambda ()
              ;; let's give LSP a chance.
              (remove-hook 'completion-at-point-functions
                           #'cider-complete-at-point)))

  (add-to-list
   'display-buffer-alist
   `(, (rx bos (or "*cider-repl"
                   "*nrepl-server"
                   "*cider-test-report*"
                   "*cider-error"
                   "*cider-result"))
       (display-buffer-reuse-window
        display-buffer-in-direction)
       (direction . right)
       (window .root)
       (dedicated . nil)
       (window-width . 0.25))))
#+end_src

Working with =+workspace= enabled in DOOM makes a new workspace to be created
for each project. However, if you start a CIDER REPL in any workspace the
special buffers are not bound to the current workspace. Let's fix this
#+begin_src emacs-lisp
;; include cider buffer into current workspace
(add-hook 'cider-repl-mode-hook
          (lambda ()
            (persp-add-buffer (current-buffer) (get-current-persp)
                              nil nil)))

;; include test report buffer to current perspective too
(add-hook 'cider-test-report-mode-hook
          (lambda ()
            (persp-add-buffer (current-buffer) (get-current-persp)
                              nil nil)))
#+end_src

*** Clojure Refactor

#+begin_src emacs-lisp
(use-package! clj-refactor
  :after clojure-mode
  :config
  (setq cljr-warn-on-eval nil
        cljr-eagerly-build-asts-on-startup nil
        cljr-add-ns-to-blank-clj-files nil ;; use lsp
        ))
#+end_src

Magnars created this amazing code called =symbol-focus= to help refactoring
activity in Clojure. The package allow us to easily edit pieces of code in
isolation.
#+begin_src emacs-lisp
(use-package! symbol-focus
  :load-path "~/.doom.d/sources/symbol-focus"
  :config
  (add-hook 'prog-mode-hook #'symbol-focus-mode)

  (map! :map symbol-focus-mode-map
      "C-s-b" #'sf/back
      "C-s-n" #'sf/next
      "C-s-p" #'sf/prev
      "C-s-r" #'sf/reset))
#+end_src

*** Parenthesis

#+begin_src emacs-lisp
(after! clojure-mode
  (add-hook 'clojure-mode-hook 'enable-paredit-mode)
  (add-hook 'cider-mode-hook 'enable-paredit-mode)
  (add-hook 'cider-repl-mode-hook 'enable-paredit-mode))
#+end_src

*** Docs

Let's enable Clojure docset for Dash.
#+begin_src emacs-lisp
;; run `dash-docs-install-docset' to get it if new installation
(set-docsets! 'clojure-mode "Clojure")
#+end_src

*** Auxiliary Functions

Execute clojure code and return the result as string
#+begin_src emacs-lisp
(defun bk/sync-eval-to-string (s)
  "Execute clojure code S and return the result as string"
  (let* ((x (concat "(do (clojure.core/in-ns '"
                    (cider-current-ns)
                    ") " s ")"))
         (dict (cider-nrepl-sync-request:eval x))
         (e (nrepl-dict-get dict "err"))
         (v (nrepl-dict-get dict "value")))
    (if e
        (user-error! e)
      v)))
#+end_src

Find the PID of the current process
#+begin_src emacs-lisp
(defun bk/clojure-pid ()
  "Find PID of current clojure process."
  (interactive)
  (message
   (bk/sync-eval-to-string
    "(-> (java.lang.management.ManagementFactory/getRuntimeMXBean)
         (.getName)
         (clojure.string/split #\"@\")
         (first))")))
#+end_src

** Java
LSP is very good to develop in Java.

#+begin_src emacs-lisp
(use-package! lsp-java
  :init
  (setq lsp-java-format-settings-profile "GoogleStyle"
        lsp-java-format-settings-url "https://raw.githubusercontent.com/google/styleguide/gh-pages/eclipse-java-google-style.xml"
        lsp-java-save-actions-organize-imports t)
  :config
  (add-hook! 'java-mode-hook (electric-pair-mode +1))
  (add-hook! 'java-mode-hook (subword-mode +1)))
#+end_src

*** Appearance

No colorful window either
#+begin_src emacs-lisp
(after! cc-mode
  (remove-hook 'java-mode-hook #'rainbow-delimiters-mode))
#+end_src

** TypeScript

This auto formatting is not good :/

#+begin_src emacs-lisp
(add-hook 'typescript-mode-hook #'format-all-mode)
(setq-hook! 'typescript-mode-hook +format-with-lsp nil)
#+end_src

* Version Control

** Magit

#+begin_src emacs-lisp
(use-package! magit
  :init
  (setq magit-diff-refine-hunk t
        magit-log-show-gpg-status t
        magit-commit-show-diff nil
        magit-display-buffer-function (lambda (buf) (display-buffer buf '(display-buffer-same-window)))
        magit-section-initial-visibility-alist
        `((untracked . show)
          (unstaged . show)
          (unpushed . show)
          (unpulled . show)
          (stashes . show)))
  :config
  (add-to-list 'magit-no-confirm 'stage-all-changes))
#+end_src

** Forge

I hack-ed my way out of Forge to create Draft PullRequests too
#+begin_src emacs-lisp
(defun bk/forge--add-draft (alist)
  "Add draft to ALIST."
  (append alist '((draft . "t"))))

(defun bk/post-draft-pull-request ()
  "Submit the post that is being edit in the current buffer as a draft."
  (interactive)
  (advice-add 'forge--topic-parse-buffer
              :filter-return #'bk/forge--add-draft)
  (condition-case err
      (forge-post-submit)
    (t
     (advice-remove 'forge--topic-parse-buffer #'bk/forge--add-draft)
     (signal (car err) (cdr err))))
  (advice-remove 'forge--topic-parse-buffer #'bk/forge--add-draft))
#+end_src

** Github
*** Bug Reference

#+begin_src emacs-lisp
(use-package! bug-reference-github
  :config
  (add-hook 'prog-mode-hook 'bug-reference-github-set-url-format))
#+end_src

*** Notifications

#+begin_src emacs-lisp
(use-package gh-notify
  :load-path "~/.doom.d/sources/gh-notify"
  :config
  (setq gh-notify-redraw-on-visit t))
#+end_src

** Code Review

I'm the maintainer of this package
#+begin_src emacs-lisp
(use-package code-review
  :load-path "~/code/code-review"
  :defer t
  :commands (code-review-start
             code-review-forge-pr-at-point)
  :config
  (map! :map forge-post-mode-map
      "C-c C-d" #'bk/post-draft-pull-request

      :map forge-topic-mode-map
      "C-c r" #'code-review-forge-pr-at-point))
#+end_src

* Key bindings

** Parenthesis

#+begin_src emacs-lisp
(map! :map paredit-mode-map
      "C-c ( n" #'paredit-add-to-next-list
      "C-c ( p" #'paredit-add-to-previous-list
      "M-s" nil ;; TODO splice needs a new place
      )
#+end_src

* Shell

** Eshell

These aliases follow me since the beginning of my Emacs experience
#+begin_src emacs-lisp
(require 'em-alias)
(add-hook 'eshell-mode-hook
          (lambda ()
            (eshell/alias "e" "find-file $1")
            (eshell/alias "ee" "find-file-other-window $1")))
#+end_src

Clean buffer with =C-l=
#+begin_src emacs-lisp
(defun eshell-clear-buffer ()
  "Clear the terminal buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))

(add-hook 'eshell-mode-hook
          (lambda ()
            (local-set-key (kbd "C-l") 'eshell-clear-buffer)))
#+end_src

* MacOS specifics

I prefer to change Command to =meta=.

#+begin_src emacs-lisp
(when IS-MAC
  (setq mac-command-modifier 'meta
        mac-option-modifier '(:ordinary super :button 2)))
#+end_src


** Search in Homebrew

Sometimes I need to verify if a package is available in homebrew or not. Making
the query from Emacs has been useful.

#+begin_src emacs-lisp
(defun bk/brew-search ()
  "Search homebrew for a file to be installed."
  (interactive "")
  (let* ((query (read-string "Search in Homebrew: "))
         (res (shell-command-to-string
               (format "brew search %s" query)))
         (res-list (-> res
                       (split-string "==> Formulae")
                       (-second-item)
                       (string-trim)
                       (split-string "\n")))
         (to-be-installed
          (completing-read
           "Install one of the packages: "
           res-list)))
    (when (not (string-empty-p to-be-installed))
      (async-shell-command
       (format "brew install %s" to-be-installed)))))
#+end_src

* Apps

I'm not sure how to classify something as an "app" inside Emacs. Perhaps they
are heavily dependent of external tools?

To be honest, most things in this section are here because I don't know a better
place to put it.

** Gif

I need to show off some Emacs work or feature and be able to record a small GIF
in seconds is perfect. During the development of my Emacs packages I've been
recording GIFs to reproduce feature behaviors to new users a lot.

#+begin_src emacs-lisp
(use-package! gif-screencast
  :config
  (setq gif-screencast-args '("-x")
        gif-screencast-cropping-program "mogrify"
        gif-screencast-capture-format "ppm"))
#+end_src


** PlantUML

Drawing diagrams to put some form to your system design ideas? Yeap!

#+begin_src emacs-lisp
(use-package! plantuml-mode
  :config
  (setq plantuml-jar-path "~/dotfiles/plantuml.jar"))
#+end_src


** Keyfreq

Important to monitor your key usage in order to improve your editing skills in
the long run. More tips [[https://github.com/wandersoncferreira/vim-mindset-apply-emacs#general-tips][here]].

#+begin_src emacs-lisp
(use-package! keyfreq
  :init
  (setq keyfreq-excluded-commands
        '(self-insert-command))
  :config
  (keyfreq-mode +1)
  (keyfreq-autosave-mode +1))
#+end_src


** VLF

Help opening very large files.

#+begin_src emacs-lisp
(use-package! vlf
  :config
  (require 'vlf-setup)
  (custom-set-variables
   '(vlf-application 'dont-ask)))
#+end_src


** IRC

I like to communicate like its the 70's again.

#+begin_src emacs-lisp
(require 'erc)
(require 'erc-track)

(setq erc-server "irc.libera.chat"
      erc-nick "bartuka"
      erc-user-full-name "Wanderson Ferreira"
      erc-track-shorten-start 8
      erc-kill-buffer-on-part t
      erc-auto-query 'bury
      erc-prompt-for-password nil)

(erc-autojoin-mode +1)
(setq erc-autojoin-channels-alist
      '(("irc.libera.chat" "#emacs" "#systemcrafters" "#code-review-emacs"))
      erc-autojoin-timing :ident
      erc-autojoin-delay 30
      erc-join-buffer 'bury)

(erc-track-mode +1)
(setq erc-keywords '("code-review" "emacs" "clojure")
      erc-track-exclude-server-buffer t
      erc-track-exclude-types '("JOIN" "PART" "QUIT" "NICK" "MODE")
      erc-track-use-faces t
      erc-track-faces-priority-list
      '(erc-current-nick-face
        erc-keyword-face
        erc-direct-msg-face)
      erc-track-priority-faces-only 'all)
#+end_src

*** Twitch IRC

I learned it was possible to connect to a Twitch chat via IRC>
#+begin_src emacs-lisp
(defun twitch-start-irc ()
  "Connect to Twitch IRC.
Get an oauth token from this website https://twitchapps.com/tmi/."
  (interactive)
  (let* ((host "irc.chat.twitch.tv")
         (user "bartuka_")
         (pwd (auth-source-pick-first-password
               :host host
               :user user)))
    (erc-tls :server host
             :port 6697
             :nick user
             :password pwd)))
#+end_src


** Ledger

Control your finances with Ledger-cli.

Activate the =ledger-mode= to every file called =ledger=
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\ledger\\'" . ledger-mode))
#+end_src

Some queries/reports that I usually follow in my ledger
#+begin_src emacs-lisp
(setq
 ledger-reports
 '(("netcash" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^assets:bank ^assets:crypto liabilities:card")
   ("sports" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:sports")
   ("doctor" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:doctor")
   ("apartamento-mae" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:mother")
   ("apartamento-misce" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:misce")
   ("eas-profit" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --invert --current bal ^expenses:eval ^income:eval")
   ("food" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:food")
   ("donation" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:donation")
   ("apartamento-morumbi" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:house")
   ("creta" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:car:creta ^equity:car:creta")
   ("networth" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank liabilities equity:apartment")
   ("spent-vs-earned" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger bal -X BRL --period=\"last 4 weeks\" ^Expenses ^Income --invert -S amount")
   ("budget" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank:checking:budget liabilities:card")
   ("taxes" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^expenses:taxes")
   ("bal" "%(binary) -f %(ledger-file) bal")
   ("reg" "%(binary) -f %(ledger-file) reg")
   ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
   ("account" "%(binary) -f %(ledger-file) reg %(account)")))
#+end_src

*** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/copy-ledger-entry ()
  "Copy last ledger entry."
  (interactive)
  (save-excursion
    (backward-sentence)
    (let ((beg (point)))
      (forward-sentence)
      (kill-ring-save beg (point))))
  (yank))

(defun bk/clean-ledger ()
  "Bring back timeline structure to the whole file."
  (interactive)
  (if (eq major-mode 'ledger-mode)
      (let ((curr-line (line-number-at-pos)))
        (ledger-mode-clean-buffer)
        (line-move (- curr-line 1)))))
#+end_src

* Authentication

I rely on =auth-source= a lot to store my passwords. A =~/.authinfo.gpg= file is
a safe way to keep passwords stored for as long as you remember your GPG
password :')

The following piece of configuration was carefully crafted to be integrated with
MacOS key manager.

#+begin_src emacs-lisp
(require 'epa-file)
(require 'org-crypt)

(setq epg-gpg-program "gpg"
      org-tags-exclude-from-inheritance (quote ("crypt"))
      password-cache-expiry nil)

(after! auth-source
  (setq auth-sources (nreverse auth-sources)
        auth-source-cache-expiry nil
        auth-source-debug t))

(after! epa
  (set 'epg-pinentry-mode nil)
  (setq epa-file-encrypt-to '("wand@hey.com")))

(epa-file-enable)
(org-crypt-use-before-save-magic)
#+end_src

** Auxiliary functions

I also have a Bitwarden account to store things in the web. This function helps
me to get some useful data in the gpg file.

#+begin_src emacs-lisp
(defun bk/bitwarden ()
  "Get bitwarden."
  (interactive)
  (kill-new (auth-source-pick-first-password
             :host "bitwarden.app"
             :user "bartuka")))
#+end_src

* Patches

Sometimes I need to overwrite some implementation in a package.

** Doom

Overwrite the =load!= macro to consider GPG configuration files.
#+begin_src emacs-lisp
(defmacro load! (filename &optional path noerror)
  "Load a file relative to the current executing file (`load-file-name').

FILENAME is either a file path string or a form that should evaluate to such a
string at run time. PATH is where to look for the file (a string representing a
directory path). If omitted, the lookup is relative to either `load-file-name',
`byte-compile-current-file' or `buffer-file-name' (checked in that order).

If NOERROR is non-nil, don't throw an error if the file doesn't exist."
  (let* ((path (or path
                   (dir!)
                   (error "Could not detect path to look for '%s' in"
                          filename)))
         (file (if path
                   `(expand-file-name ,filename ,path)
                 filename)))
    `(if (string-match-p ".gpg$" ,file)
         (add-hook 'after-init-hook (lambda () (load-file ,file)))
       (condition-case-unless-debug e
           (let (file-name-handler-alist)
             (load ,file ,noerror 'nomessage))
         (doom-error (signal (car e) (cdr e)))
         (error (doom--handle-load-error e ,file ,path))))))
#+end_src

* Work

Every now and then I have to write some elisp code to help me in my work. I like
to keep them organized to keep at least some context to where/why the function
came to existence.

** App Sauce

First time I experimented with Git Worktrees in day to day work. Really liked
it. A git worktree + projectile + a dedicated clojure REPL connected == Great
experience!

#+begin_src emacs-lisp
(defun bk/create-worktree ()
  "Help development on multiple branches."
  (interactive)
  (let* ((root-proj (projectile-project-root))
         (proj-name (car (cdr (nreverse (split-string root-proj "/")))))
         (dest-dir (file-name-directory (directory-file-name root-proj)))
         (branch (ido-completing-read "Choose the branch: " (magit-list-local-branch-names)))
         (worktree-path (concat dest-dir proj-name "-wt-" branch)))
    (magit-worktree-checkout worktree-path branch)
    (projectile-find-file)))

(defun bk/delete-worktree ()
  "Delete worktree and all its open buffers."
  (interactive)
  (let ((worktree (ido-completing-read "Choose worktree: " (magit-list-worktrees))))
    (mapc (lambda (buffer)
            (with-current-buffer buffer
              (let ((worktree-name (file-name-base worktree)))
                (when (string-equal (projectile-project-name) worktree-name)
                  (kill-buffer buffer)))))
          (buffer-list))
    (projectile-remove-current-project-from-known-projects)
    (magit-worktree-delete worktree)))
#+end_src

** Reify Health

Basic functions to connect to Clojure REPL.
#+begin_src emacs-lisp
(defun reifyhealth/cider-connect ()
  "Connect into eSource."
  (interactive)
  (cider-connect-clj (list :host "localhost" :port 12344)))
#+end_src

Open my specific notes from work.
#+begin_src emacs-lisp
(defun reifyhealth ()
  "Open file notes from work."
  (interactive)
  (find-file "~/repos/reifyhealth/work.org"))
#+end_src

and we had to generate UUIDs to mock some tests every so often.
#+begin_src emacs-lisp
(defun bk/uuid ()
  "Create uuid and add to clipboard."
  (interactive)
  (kill-new (uuidgen-4)))
#+end_src

** Cisco

Good stuff.
#+begin_src emacs-lisp
(load! "+work-cisco.el.gpg")
#+end_src
