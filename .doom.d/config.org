#+TITLE: Emacs configuration
#+AUTHOR: Wanderson Ferreira
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: fold

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* Summary :TOC_3_gh:
- [[#general][General]]
  - [[#scratch-buffer][Scratch buffer]]
  - [[#disabled-major-modes][Disabled major modes]]
- [[#editing][Editing]]
  - [[#iedit][iEdit]]
  - [[#auxiliary-functions][Auxiliary Functions]]
  - [[#bindings][Bindings]]
  - [[#abbreviations][Abbreviations]]
    - [[#auxiliary-functions-1][Auxiliary Functions]]
    - [[#bindings-1][Bindings]]
- [[#search][Search]]
- [[#spelling][Spelling]]
- [[#project][Project]]
  - [[#projectile][Projectile]]
- [[#completion][Completion]]
  - [[#company][Company]]
- [[#appearance][Appearance]]
- [[#window][Window]]
  - [[#moving][Moving]]
  - [[#better-split][Better split]]
  - [[#workspace][Workspace]]
    - [[#change-modeline-workspace-name][Change modeline workspace name]]
- [[#programming][Programming]]
  - [[#lsp][LSP]]
  - [[#emacs-lisp][Emacs Lisp]]
    - [[#appearance-1][Appearance]]
    - [[#taming-parenthesis][Taming Parenthesis]]
    - [[#test-frameworks][Test frameworks]]
  - [[#clojure][Clojure]]
    - [[#clojure-mode][Clojure Mode]]
    - [[#cider][CIDER]]
    - [[#clojure-refactor][Clojure Refactor]]
    - [[#parenthesis][Parenthesis]]
    - [[#docs][Docs]]
    - [[#auxiliary-functions-2][Auxiliary Functions]]
  - [[#java][Java]]
    - [[#appearance-2][Appearance]]
  - [[#typescript][TypeScript]]
- [[#org-mode][Org mode]]
- [[#version-control][Version Control]]
  - [[#magit][Magit]]
  - [[#forge][Forge]]
  - [[#github][Github]]
    - [[#bug-reference][Bug Reference]]
    - [[#notifications][Notifications]]
  - [[#code-review][Code Review]]
- [[#key-bindings][Key bindings]]
  - [[#registers][Registers]]
  - [[#general-1][General]]
  - [[#parenthesis-1][Parenthesis]]
- [[#shell][Shell]]
  - [[#eshell][Eshell]]
- [[#macos-specifics][MacOS specifics]]
  - [[#search-in-homebrew][Search in Homebrew]]
- [[#apps][Apps]]
  - [[#gif][Gif]]
  - [[#plantuml][PlantUML]]
  - [[#keyfreq][Keyfreq]]
  - [[#vlf][VLF]]
  - [[#irc][IRC]]
    - [[#twitch-irc][Twitch IRC]]
  - [[#ledger][Ledger]]
    - [[#auxiliary-functions-3][Auxiliary Functions]]
- [[#authentication][Authentication]]
  - [[#auxiliary-functions-4][Auxiliary functions]]
- [[#patches][Patches]]
  - [[#doom][Doom]]
- [[#work][Work]]
  - [[#app-sauce][App Sauce]]
  - [[#reify-health][Reify Health]]
  - [[#cisco][Cisco]]

* General

#+begin_src emacs-lisp
(setq user-full-name "Wanderson Ferreira"
      user-mail-address "wand@hey.com"

      scroll-margin 2
      line-spacing 3

      enable-local-variables t
      messages-buffer-max-lines 10000

      load-prefer-newer t
      show-help-function nil
      read-process-output-max (* 1024 1024)
      dired-listing-switches "-ahl -v")
#+end_src

Remove byte compilation warnings related to old =cl= library.
#+begin_src emacs-lisp
(setq byte-compile-warnings '(cl-functions))
#+end_src

** Scratch buffer

#+begin_src emacs-lisp
(setq doom-scratch-initial-major-mode 'emacs-lisp-mode
      initial-major-mode 'emacs-lisp-mode)
#+end_src

** Disabled major modes

highlighting current line is very distracting to me.
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'global-hl-line-mode)
#+end_src

Paredit >> Smartparens IMHO
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'smartparens-global-mode)
#+end_src

* Editing

UTF-8
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

Kill additional whitespaces when joining lines
#+begin_src emacs-lisp
(defadvice kill-line (before kill-line-autoreindent activate)
  "Kill excess whitespace when joining lines.
If the next line is joined to the current line, kill the extra indent whitespace."
  (when (and (eolp) (not (bobp)))
    (save-excursion
      (forward-char 1)
      (just-one-space 1))))
#+end_src

Copy and cut single line when no region available.
#+begin_src emacs-lisp
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Single line killed")
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no activate region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+end_src

** iEdit

#+begin_src emacs-lisp
;; when you hit Ctrl+;, all occurrences of the symbol under the cursor (or
;; current selection) are highlighted, and any changes you make on one of them
;; will be automatically applied to all others.
(use-package! iedit
  :defer
  :config
  (set-face-background 'iedit-occurrence "saddle brown")
  :bind
  ("C-;" . iedit-mode))
#+end_src

** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/point-to-register ()
  "Store cursor position in a register."
  (interactive)
  (point-to-register 8)
  (message "Point set"))

 (defun bk/jump-to-register ()
  "Switch between current pos and stored pos."
  (interactive)
  (let ((tmp (point-marker)))
    (jump-to-register 8)
    (set-register 8 tmp)))

(defun bk/kill-inner-word ()
  "Equivalent to ciw in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))

(defun bk/copy-whole-line ()
  "Copies a line without refard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol)))))

(defun bk/zap-to-char-backward (arg char)
  (interactive "p\ncZap up to char backward: ")
  (save-excursion
    (zap-up-to-char -1 char)))
#+end_src

** Bindings
#+begin_src emacs-lisp
(map!
 "C-c r p" #'bk/point-to-register
 "C-c r j" #'bk/jump-to-register
 "C-c k w" #'bk/kill-inner-word
 "C-c k f" #'zap-up-to-char
 "C-c k b" #'bk/zap-to-char-backward
 "C-c y l" #'bk/copy-whole-line)
#+end_src

** Abbreviations

Use single abbrev-table for multiple modes
#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

Default global table
#+begin_src emacs-lisp
(define-abbrev-table 'global-abbrev-table
  '(
    ("reuslt" "result" nil 0)
    ("requier" "require" nil 0)
    ))
#+end_src

*** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/add-region-local-abbrev (start end)
  "Go from START to END and add the selected text to a local abbrev."
  (interactive "r")
  (if (use-region-p)
      (let ((num-words (count-words-region start end)))
        (add-mode-abbrev num-words)
        (deactivate-mark))
    (message "No selected region!")))

(defun bk/add-region-global-abbrev (start end)
  "Go from START to END and add the selected text to global abbrev."
  (interactive "r")
  (if (use-region-p)
      (let ((num-words (count-words-region start end)))
        (add-abbrev global-abbrev-table "Global" num-words)
        (deactivate-mark))
    (message "No selected region!")))
#+end_src

*** Bindings

#+begin_src emacs-lisp
(map!
 "C-x a l" #'bk/add-region-local-abbrev
 "C-x a g" #'bk/add-region-global-abbrev)
#+end_src

* Search

Workaround to make =deadgrep= consider hidden folders and symlinks
#+begin_src emacs-lisp
(require 'deadgrep)

(defun deadgrep--include-args (rg-args)
  (push "--hidden" rg-args) ;; consider hidden folders/files
  (push "--follow" rg-args) ;; follow symlink
  )

(advice-add 'deadgrep--arguments :filter-return #'deadgrep--include-args)
#+end_src

* Spelling

Langtool is very useful to not native English speakers. You can download the jar from [[curl -o langtool.zip https://languagetool.org/download/LanguageTool-stable.zip && unzip langtool.zip][here]]
#+begin_src emacs-lisp
(setq langtool-language-tool-jar "~/Downloads/LanguageTool-5.5/languagetool-commandline.jar")
#+end_src

Change dictionary of Ispell
#+begin_src emacs-lisp
(defun bk/dict-pt ()
  "Change to pt-BR dictionary."
  (interactive)
  (ispell-change-dictionary "pt_BR"))

(defun bk/dict-en ()
  "Change to en dictionary."
  (ispell-change-dictionary "en"))
#+end_src

* Project

** Projectile

Disable cache
#+begin_src emacs-lisp
(setq projectile-enable-caching nil)
#+end_src

Direct projectile to look for code in a specific folder.
#+begin_src emacs-lisp
(setq projectile-project-search-path '("~/code"))
#+end_src

* Completion

** Company
#+begin_src emacs-lisp
(use-package! company
  :init
  (setq company-idle-delay 0.1
        company-show-quick-access t
        company-icon-size 20)
  :config
  (set-company-backend! 'prog-mode nil)
  (set-company-backend! 'prog-mode
    '(:separate company-capf company-files company-dabbrev-code company-yasnippet))
  (define-key company-active-map [(control) (meta) ?s] 'company-search-candidates)
  (define-key company-active-map "\C-s" 'company-filter-candidates))
#+end_src

* Appearance

Doom comes with some nice themes. For now, I've been using Zenburn most of the
time.

#+begin_src emacs-lisp
(setq doom-theme 'doom-zenburn
      doom-font (font-spec :family "Monaco" :size 14)
      doom-themes-treemacs-theme "all-the-icons"
      fill-column 180
      display-line-numbers-type nil
      confirm-kill-emacs nil
      indent-tabs-mode nil)

(when IS-LINUX
  (setq doom-font (font-spec :family "Source Code Pro" :size 15))
  (setq doom-theme 'modus-operandi))

;; delete selection
(delete-selection-mode +1)

;; uniquify
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)

(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (outline-minor-mode -1)))

(defun bk/default-theme ()
  "Change highlight colors when using the default white theme."
  (set-face-attribute 'lazy-highlight nil :background "khaki1")
  (set-face-attribute 'isearch nil :background "khaki1")
  (set-face-attribute 'region nil :background "khaki1"))

(defun bk/slate-gray-theme ()
  "Slate Grat"
  (interactive)
  (set-background-color "DarkSlateGray")
  (set-face-background 'mode-line "Wheat")
  (set-face-foreground 'mode-line "DarkSlateGray")
  (set-foreground-color "Wheat"))

(defun what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property pos 'read-face-name)
                  (get-char-property pos 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))

;; hacky: avoid saving custom faces in custom.el files
(defun custom-save-faces ()
  "No-op"
  (interactive))

(defun bk/alect-themes-customizations ()
  (custom-set-faces
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(font-lock-variable-name-face ((t (:foreground "#6a621b"))))
   '(ivy-current-match ((t (:extend t :background "#b0d0f3" :foreground "#101010" :weight bold))))
   '(lsp-lsp-flycheck-info-unnecessary-face ((t (:foreground "#2020cc" :underline (:color "dark orange" :style wave)))) t)))

(defun bk/high-contrast-customizations ()
  (custom-set-faces
   '(mode-line ((t (:background "Gray75" :foreground "Black"))))
   '(mode-line-buffer-id ((t (:background "Gray75" :foreground "blue4"))))
   '(mode-line-mousable ((t (:background "Gray75" :foreground "firebrick"))))
   '(mode-line-mousable-minor-mode ((t (:background "Gray75" :foreground "green4"))))))

(defun bk/toggle-transparency ()
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                    ((numberp (cdr alpha)) (cdr alpha))
                    ((numberp (cadr alpha)) (cadr alpha)))
              100)
         80
       100))))

(defun bk/default-black-customizations ()
  "Customizations to be used with default black theme in Doom Emacs"
  (custom-set-faces
   '(doom-modeline-buffer-path ((t (:foreground "black" :weight bold))))
   '(doom-modeline-project-dir ((t (:foreground "black" :weight bold))))
   '(doom-modeline-buffer-modified ((t (:foreground "Blue" :weight bold))))
   '(success ((t (:foreground "ForestGreen" :weight bold))))))

;; control the modeline info
(use-package! delight
  :config
  (delight '(;; general
             (whitespace-mode nil whitespace)
             (vi-tilde-fringe-mode nil vi-tilde-fringe)
             (ws-butler-mode nil ws-butler)
             (eldoc-mode nil eldoc)
             (gcmh-mode nil gcmh)
             (which-key-mode nil which-key)
             (better-jumper-local-mode nil better-jumper)
             (company-mode nil company)
             (company-box-mode nil company-box)
             (paredit-mode nil paredit)
             (ivy-mode nil ivy)
             (ivy-posframe-mode nil ivy-posframe)
             (org-roam-mode nil org-roam)
             (git-gutter-mode nil git-gutter)
             (volatile-highlights-mode nil volatile-highlights)
             (yas-minor-mode nil yasnippet)
             (abbrev-mode nil abbrev)
             (annotate-mode nil annotate)
             (symbol-focus-mode nil symbol-focus)
             (lsp-lens-mode nil lsp-lens)

             ;; clojure
             (clj-refactor-mode nil clj-refactor)
             (dtrt-indent-mode nil dtrt-indent))))
#+end_src

* Window

Recenter on next-error
#+begin_src emacs-lisp
(add-hook! 'next-error-hook #'recenter)
#+end_src

** Moving

Use shift arrows to move between windows.
#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src

However, Org mode requires a little workaround to make shift arrow movements to
work.
#+begin_src emacs-lisp
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src

** Better split

When you split the buffer in any direction, move the cursor there and show the
previous buffer.
#+begin_src emacs-lisp
(defun bk/vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun bk/hsplit-last-buffer ()
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))
#+end_src

Overwrite the default split bindings
#+begin_src emacs-lisp
(map! "C-x 2" #'bk/vsplit-last-buffer
      "C-x 3" #'bk/hsplit-last-buffer)
#+end_src

** Workspace

Using a dedicated set of buffers to specific kind of work has been interesting.
There are some annoyances along the way but we can fix it.

I want to switch to a new workspace automatically if I change projectile
projects.
#+begin_src emacs-lisp
(setq +workspaces-on-switch-project-behavior t)
#+end_src

Also delete the workspace automatically if there is no buffers associated anymore
#+begin_src emacs-lisp
(setq persp-autokill-persp-when-removed-last-buffer t)
#+end_src

Remove the modeline indicator of Projectile.
#+begin_src emacs-lisp
(use-package! projectile
  :delight projectile-mode)
#+end_src

*** Change modeline workspace name

Overwrite the Doom function that writes to the modeline.
#+begin_src emacs-lisp
(after! persp
  (setq persp-lighter
        '(:eval
          (format
           (propertize
            " #%.10s"
            'face (let ((persp (get-current-persp)))
                    (if persp
                        (if (persp-contain-buffer-p (current-buffer) persp)
                            'persp-face-lighter-default
                          'persp-face-lighter-buffer-not-in-persp)
                      'persp-face-lighter-nil-persp)))
           (safe-persp-name (get-current-persp))))))
#+end_src

* Programming

** LSP

#+begin_src emacs-lisp
(use-package! lsp-mode
  :init
  (setq lsp-enable-file-watchers t
        lsp-enable-symbol-highlighting t
        lsp-eldoc-enable-hover t
        lsp-lens-enable t
        lsp-idle-delay 0.1
        lsp-headerline-breadcrumb-enable nil)
  :config
  (add-to-list 'lsp-file-watch-ignored-directories "classes")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\minio\\'")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\terraform\\'")

  (add-hook! 'lsp-before-open-hook
    (remove-hook! 'lsp-completion-mode-hook #'+lsp-init-company-backends-h))

  (advice-add #'lsp-rename :after (lambda (&rest _) (projectile-save-project-buffers))))
#+end_src

#+begin_src emacs-lisp
(use-package! lsp-ui
  :after lsp-mode
  :commands lsp-ui-mode
  :config
  (setq lsp-ui-doc-max-width 60
        lsp-ui-doc-position 'top
        lsp-ui-doc-delay 0.2
        lsp-ui-peek-list-width 60
        lsp-ui-peek-fontify 'always
        lsp-ui-sideline-show-code-actions nil))
#+end_src

#+begin_src emacs-lisp
 (use-package! lsp-treemacs
  :config
  (setq lsp-treemacs-error-list-current-project-only t))

(use-package! treemacs-all-the-icons
  :after treemacs)
#+end_src

** Emacs Lisp

*** Appearance

I don't like the too colorful buffers. So, removing the rainbow delimiter mode.
#+begin_src emacs-lisp
(after! elisp-mode
  (remove-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode))
#+end_src

*** Taming Parenthesis

You will definitely hate Lisp if you don't understand structural editing.
#+begin_src emacs-lisp
(after! elisp-mode
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode))
#+end_src

*** Test frameworks

Buttercup (Behavior Driven Emacs Lisp Testing) framework has one annoyance when
you run the test suite: it moves the cursor from the point to the end of the
test file. This =advice= is a workaround to keep the point where it was:
#+begin_src emacs-lisp
(use-package! buttercup
  :config
  (define-advice buttercup--run-suites (:around (orig-fun &rest args))
    "Keep the cursor at-point after running test suite with buttercup."
    (setq save-point (point))
    (unwind-protect
        (apply orig-fun args)
      (goto-char save-point))))
#+end_src

** Clojure

Very lucky to be working with Clojure for so many years. I've learned a lot
about FP and other languages in the process and so many great people in the
community.

*** Clojure Mode

#+begin_src emacs-lisp
(use-package! clojure-mode
  :init
  (setq clojure-thread-all-but-last t)
  :config
  (cljr-add-keybindings-with-prefix "C-c C-m")
  (remove-hook 'clojure-mode-hook #'rainbow-delimiters-mode))
#+end_src

Sometimes I forget to start the REPL and I try to use a CIDER command. This
warning message is very helpful.
#+begin_src emacs-lisp
(defun bk/nrepl-warn-when-not-connected ()
  (interactive)
  (message "Oops! You'are not connected to an nREPL server."))

(map! :map clojure-mode-map
      "C-x C-e" #'bk/nrepl-warn-when-not-connected
      "C-c C-k" #'bk/nrepl-warn-when-not-connected
      "C-c C-z" #'bk/nrepl-warn-when-not-connected

      ;; tests
      "C-c k t" #'kaocha-runner-run-test-at-point
      "C-c k r" #'kaocha-runner-run-tests
      "C-c k a" #'kaocha-runner-run-all-tests
      "C-c k w" #'kaocha-runner-show-warnings
      "C-c k h" #'kaocha-runner-hide-windows)
#+end_src

*** CIDER

#+begin_src emacs-lisp
(use-package! cider
  :after clojure-mode
  :init
  (setq cider-jdk-src-paths '("~/Downloads/clojure-1.10.3-sources" "~/Downloads/jvm11/source")
        cider-show-error-buffer t
        cider-save-file-on-load t
        cider-eldoc-display-for-symbol-at-point nil ;; use lsp
        cider-repl-use-pretty-printing nil
        cider-redirect-server-output-to-repl t
        clojure-toplevel-inside-comment-form t
        cider-clojure-cli-command "~/code/dotfiles/clojure/clojure-bin-enriched")
  :config
  (add-hook! 'cider-test-report-mode-hook 'toggle-truncate-lines)
  (add-hook 'cider-mode-hook
            (lambda ()
              ;; let's give LSP a chance.
              (remove-hook 'completion-at-point-functions
                           #'cider-complete-at-point)))

  (add-to-list
   'display-buffer-alist
   `(, (rx bos (or "*cider-repl"
                   "*nrepl-server"
                   "*cider-test-report*"
                   "*cider-error"
                   "*cider-result"))
       (display-buffer-reuse-window
        display-buffer-in-direction)
       (direction . right)
       (window .root)
       (dedicated . nil)
       (window-width . 0.25))))
#+end_src

Working with =+workspace= enabled in DOOM makes a new workspace to be created
for each project. However, if you start a CIDER REPL in any workspace the
special buffers are not bound to the current workspace. Let's fix this
#+begin_src emacs-lisp
;; include cider buffer into current workspace
(add-hook 'cider-repl-mode-hook
          (lambda ()
            (persp-add-buffer (current-buffer) (get-current-persp)
                              nil nil)))

;; include test report buffer to current perspective too
(add-hook 'cider-test-report-mode-hook
          (lambda ()
            (persp-add-buffer (current-buffer) (get-current-persp)
                              nil nil)))
#+end_src

**** Patch to Hotload dependencies

Experimental configuration to hotload refactor using Pomegranate from Cemerick
and integrating it in clj-refactor.

#+begin_src emacs-lisp
(after! cider-mode

  (setq cljr-hotload-dependencies t)

  (defun bk/send-to-repl (sexp eval ns)
    (ignore eval)
    (cider-switch-to-repl-buffer ns)
    (goto-char cider-repl-input-start-mark)
    (delete-region (point) (point-max))
    (save-excursion
      (insert sexp)
      (when (equal (char-before) ?\n)
        (delete-char -1))
      (cider-repl--send-input t))
    (delete-region (point) (point-max)))

  (defun bk/pomegranate-dep (dep)
    (concat
     (format
      "%s"
      `(use '[cemerick.pomegranate :only (add-dependencies)]))
     (s-replace-all
      `(("\\." . ".")
        ("mydep" . ,dep))
      (format
       "%S"
       `(add-dependencies :coordinates '[mydep]
                          :repositories (merge cemerick.pomegranate.aether/maven-central
                                               {"clojars" "https://clojars.org/repo"}))))))

  (defun cljr-hotload-dependency (artifact version &optional dep ns)
    (ignore dep)
    (bk/send-to-repl
     (bk/pomegranate-dep (format "[%s \"%s\"]" artifact version))
     t ns))

  (defun cljr--add-project-dependency (artifact version)
    (let* ((project-file (cljr--project-file))
           (deps (cljr--project-with-deps-p project-file)))
      (cljr--update-file project-file
        (goto-char (point-min))
        (if deps
            (cljr--insert-into-clj-dependencies artifact version)
          (cljr--insert-into-leiningen-dependencies artifact version))
        (cljr--post-command-message "Added %s version %s as a project dependency" artifact version))
      (when cljr-hotload-dependencies
        (if deps
            (back-to-indentation)
          (paredit-backward-down))
        (cljr-hotload-dependency artifact version)))))

#+end_src

*** Clojure Refactor

#+begin_src emacs-lisp
(use-package! clj-refactor
  :after clojure-mode
  :config
  (setq cljr-warn-on-eval nil
        cljr-eagerly-build-asts-on-startup nil
        cljr-add-ns-to-blank-clj-files nil ;; use lsp
        ))
#+end_src

Magnars created this amazing code called =symbol-focus= to help refactoring
activity in Clojure. The package allow us to easily edit pieces of code in
isolation.
#+begin_src emacs-lisp
(use-package! symbol-focus
  :load-path "~/.doom.d/sources/symbol-focus"
  :config
  (add-hook 'prog-mode-hook #'symbol-focus-mode)

  (map! :map symbol-focus-mode-map
      "C-s-b" #'sf/back
      "C-s-n" #'sf/next
      "C-s-p" #'sf/prev
      "C-s-r" #'sf/reset))
#+end_src

*** Parenthesis

#+begin_src emacs-lisp
(after! clojure-mode
  (add-hook 'clojure-mode-hook 'enable-paredit-mode)
  (add-hook 'cider-mode-hook 'enable-paredit-mode)
  (add-hook 'cider-repl-mode-hook 'enable-paredit-mode))
#+end_src

*** Docs

Let's enable Clojure docset for Dash.
#+begin_src emacs-lisp
;; run `dash-docs-install-docset' to get it if new installation
(set-docsets! 'clojure-mode "Clojure")
#+end_src

*** Auxiliary Functions

Execute clojure code and return the result as string
#+begin_src emacs-lisp
(defun bk/sync-eval-to-string (s)
  "Execute clojure code S and return the result as string"
  (let* ((x (concat "(do (clojure.core/in-ns '"
                    (cider-current-ns)
                    ") " s ")"))
         (dict (cider-nrepl-sync-request:eval x))
         (e (nrepl-dict-get dict "err"))
         (v (nrepl-dict-get dict "value")))
    (if e
        (user-error! e)
      v)))
#+end_src

Find the PID of the current process
#+begin_src emacs-lisp
(defun bk/clojure-pid ()
  "Find PID of current clojure process."
  (interactive)
  (message
   (bk/sync-eval-to-string
    "(-> (java.lang.management.ManagementFactory/getRuntimeMXBean)
         (.getName)
         (clojure.string/split #\"@\")
         (first))")))
#+end_src

** Java
LSP is very good to develop in Java.

#+begin_src emacs-lisp
(use-package! lsp-java
  :init
  (setq lsp-java-format-settings-profile "GoogleStyle"
        lsp-java-format-settings-url "https://raw.githubusercontent.com/google/styleguide/gh-pages/eclipse-java-google-style.xml"
        lsp-java-save-actions-organize-imports t)
  :config
  (add-hook! 'java-mode-hook (electric-pair-mode +1))
  (add-hook! 'java-mode-hook (subword-mode +1)))
#+end_src

*** Appearance

No colorful window either
#+begin_src emacs-lisp
(after! cc-mode
  (remove-hook 'java-mode-hook #'rainbow-delimiters-mode))
#+end_src

** TypeScript

This auto formatting is not good :/

#+begin_src emacs-lisp
(add-hook 'typescript-mode-hook #'format-all-mode)
(setq-hook! 'typescript-mode-hook +format-with-lsp nil)
#+end_src

* Org mode

#+begin_src emacs-lisp
(use-package! org
  :init
  (setq org-return-follows-link t
        org-directory "~/org/"
        org-fontify-quote-and-verse-blocks nil
        org-fontify-whole-heading-line nil
        org-hide-leading-stars nil
        org-startup-indented nil
        org-agenda-files (list "~/agenda/todo.org"))
  :config
  (remove-hook 'org-mode-hook #'org-superstar-mode))

(setq org-download-method 'directory)

;;; blog
(setq org-hugo-base-dir "~/wandersoncferreira.github.io"
      org-hugo-section "items"
      org-hugo-front-matter-format "yaml")

;; zettelkasten
(if IS-MAC
    (setq org-roam-directory "/Users/wferreir/roam-v2")
  (setq org-roam-directory "/home/wanderson/zettelkasten"))

(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))

;; spaced-repetition
(use-package org-fc
  :load-path "~/.doom.d/sources/org-fc"
  :custom (org-fc-directories '("~/roam-v2"))
  :config
  (add-to-list 'org-fc-custom-contexts
               '(security-cards . (:filter (tag "security"))))
  (add-to-list 'org-fc-custom-contexts
               '(comptia-QA . (:filter (tag "comptia-qa")))))

#+end_src

* Version Control

** Magit

#+begin_src emacs-lisp
(use-package! magit
  :init
  (setq magit-diff-refine-hunk t
        magit-log-show-gpg-status t
        magit-commit-show-diff nil
        magit-display-buffer-function (lambda (buf) (display-buffer buf '(display-buffer-same-window)))
        magit-section-initial-visibility-alist
        `((untracked . show)
          (unstaged . show)
          (unpushed . show)
          (unpulled . show)
          (stashes . show)))
  :config
  (add-to-list 'magit-no-confirm 'stage-all-changes))
#+end_src

** Forge

I hack-ed my way out of Forge to create Draft PullRequests too
#+begin_src emacs-lisp
(defun bk/forge--add-draft (alist)
  "Add draft to ALIST."
  (append alist '((draft . "t"))))

(defun bk/post-draft-pull-request ()
  "Submit the post that is being edit in the current buffer as a draft."
  (interactive)
  (advice-add 'forge--topic-parse-buffer
              :filter-return #'bk/forge--add-draft)
  (condition-case err
      (forge-post-submit)
    (t
     (advice-remove 'forge--topic-parse-buffer #'bk/forge--add-draft)
     (signal (car err) (cdr err))))
  (advice-remove 'forge--topic-parse-buffer #'bk/forge--add-draft))
#+end_src

** Github
*** Bug Reference

#+begin_src emacs-lisp
(use-package! bug-reference-github
  :config
  (add-hook 'prog-mode-hook 'bug-reference-github-set-url-format))
#+end_src

*** Notifications

#+begin_src emacs-lisp
(use-package gh-notify
  :load-path "~/.doom.d/sources/gh-notify"
  :config
  (setq gh-notify-redraw-on-visit t))
#+end_src

** Code Review

I'm the maintainer of this package
#+begin_src emacs-lisp
(use-package code-review
  :load-path "~/code/code-review"
  :defer t
  :commands (code-review-start
             code-review-forge-pr-at-point)
  :config
  (map! :map forge-post-mode-map
      "C-c C-d" #'bk/post-draft-pull-request

      :map forge-topic-mode-map
      "C-c r" #'code-review-forge-pr-at-point))
#+end_src

* Key bindings

Minor default changes
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.4
      tab-always-indent 'complete)
#+end_src

Disabling =C-x p= because I really like to pop to mark with these keys.
#+begin_src emacs-lisp
(map! "C-x p" nil)
#+end_src

Enabling disabled commands
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+end_src

** Registers

#+begin_src emacs-lisp
(set-register ?l '(file . "/Users/wferreir/ledger"))
(set-register ?b '(file . "/Users/wferreir/dotfiles/macos/Brewfile"))
#+end_src

** General

#+begin_src emacs-lisp
(map!
 ;; C-x keys
 "C-x b" #'+vertico/switch-workspace-buffer
 "C-x p" #'pop-to-mark-command
 "C-x k" #'kill-this-buffer
 "C-x C-m" #'execute-extended-command
 "C-x C-j" #'dired-jump

 ;; super keys
 "s-t" #'projectile-toggle-between-implementation-and-test
 "s-'" #'cycle-quotes
 "s-s" #'deadgrep
 "s-g" #'gh-notify
 "s-p" #'+popup/toggle

 ;; F-* keys
 "<f5>" #'deadgrep
 "<f9>" #'gif-screencast-start-or-stop
 "<f12>" #'pomidor

 ;; C-c keys
 "C-c d" #'crux-duplicate-current-line-or-region
 "C-c c SPC" #'rotate-layout

 ;; editor
 "M-p" #'jump-char-backward
 "M-n" #'jump-char-forward
 "M-i" #'change-inner
 "M-u" #'fix-word-upcase
 "M-l" #'fix-word-downcase
 "M-c" #'fix-word-capitalize
 "C-<up>" #'move-text-up
 "C-<down>" #'move-text-down

 ;; movement
 "C-:" #'avy-goto-char
 "M-g w" #'avy-goto-word-1

 ;; completion
 "C-." #'completion-at-point
 )
#+end_src

** Parenthesis

#+begin_src emacs-lisp
(map! :map paredit-mode-map
      "C-c ( n" #'paredit-add-to-next-list
      "C-c ( p" #'paredit-add-to-previous-list
      "M-s" nil ;; TODO splice needs a new place
      )
#+end_src

* Shell

** Eshell

These aliases follow me since the beginning of my Emacs experience
#+begin_src emacs-lisp
(require 'em-alias)
(add-hook 'eshell-mode-hook
          (lambda ()
            (eshell/alias "e" "find-file $1")
            (eshell/alias "ee" "find-file-other-window $1")))
#+end_src

Clean buffer with =C-l=
#+begin_src emacs-lisp
(defun eshell-clear-buffer ()
  "Clear the terminal buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))

(add-hook 'eshell-mode-hook
          (lambda ()
            (local-set-key (kbd "C-l") 'eshell-clear-buffer)))
#+end_src

* MacOS specifics

I prefer to change Command to =meta=.

#+begin_src emacs-lisp
(when IS-MAC
  (setq mac-command-modifier 'meta
        mac-option-modifier '(:ordinary super :button 2)))
#+end_src


** Search in Homebrew

Sometimes I need to verify if a package is available in homebrew or not. Making
the query from Emacs has been useful.

#+begin_src emacs-lisp
(defun bk/brew-search ()
  "Search homebrew for a file to be installed."
  (interactive "")
  (let* ((query (read-string "Search in Homebrew: "))
         (res (shell-command-to-string
               (format "brew search %s" query)))
         (res-list (-> res
                       (split-string "==> Formulae")
                       (-second-item)
                       (string-trim)
                       (split-string "\n")))
         (to-be-installed
          (completing-read
           "Install one of the packages: "
           res-list)))
    (when (not (string-empty-p to-be-installed))
      (async-shell-command
       (format "brew install %s" to-be-installed)))))
#+end_src

* Apps

I'm not sure how to classify something as an "app" inside Emacs. Perhaps they
are heavily dependent of external tools?

To be honest, most things in this section are here because I don't know a better
place to put it.

** Gif

I need to show off some Emacs work or feature and be able to record a small GIF
in seconds is perfect. During the development of my Emacs packages I've been
recording GIFs to reproduce feature behaviors to new users a lot.

#+begin_src emacs-lisp
(use-package! gif-screencast
  :config
  (setq gif-screencast-args '("-x")
        gif-screencast-cropping-program "mogrify"
        gif-screencast-capture-format "ppm"))
#+end_src


** PlantUML

Drawing diagrams to put some form to your system design ideas? Yeap!

#+begin_src emacs-lisp
(use-package! plantuml-mode
  :config
  (setq plantuml-jar-path "~/dotfiles/plantuml.jar"))
#+end_src


** Keyfreq

Important to monitor your key usage in order to improve your editing skills in
the long run. More tips [[https://github.com/wandersoncferreira/vim-mindset-apply-emacs#general-tips][here]].

#+begin_src emacs-lisp
(use-package! keyfreq
  :init
  (setq keyfreq-excluded-commands
        '(self-insert-command))
  :config
  (keyfreq-mode +1)
  (keyfreq-autosave-mode +1))
#+end_src


** VLF

Help opening very large files.

#+begin_src emacs-lisp
(use-package! vlf
  :config
  (require 'vlf-setup)
  (custom-set-variables
   '(vlf-application 'dont-ask)))
#+end_src


** IRC

I like to communicate like its the 70's again.

#+begin_src emacs-lisp
(require 'erc)
(require 'erc-track)

(setq erc-server "irc.libera.chat"
      erc-nick "bartuka"
      erc-user-full-name "Wanderson Ferreira"
      erc-track-shorten-start 8
      erc-kill-buffer-on-part t
      erc-auto-query 'bury
      erc-prompt-for-password nil)

(erc-autojoin-mode +1)
(setq erc-autojoin-channels-alist
      '(("irc.libera.chat" "#emacs" "#systemcrafters" "#code-review-emacs"))
      erc-autojoin-timing :ident
      erc-autojoin-delay 30
      erc-join-buffer 'bury)

(erc-track-mode +1)
(setq erc-keywords '("code-review" "emacs" "clojure")
      erc-track-exclude-server-buffer t
      erc-track-exclude-types '("JOIN" "PART" "QUIT" "NICK" "MODE")
      erc-track-use-faces t
      erc-track-faces-priority-list
      '(erc-current-nick-face
        erc-keyword-face
        erc-direct-msg-face)
      erc-track-priority-faces-only 'all)
#+end_src

*** Twitch IRC

I learned it was possible to connect to a Twitch chat via IRC>
#+begin_src emacs-lisp
(defun twitch-start-irc ()
  "Connect to Twitch IRC.
Get an oauth token from this website https://twitchapps.com/tmi/."
  (interactive)
  (let* ((host "irc.chat.twitch.tv")
         (user "bartuka_")
         (pwd (auth-source-pick-first-password
               :host host
               :user user)))
    (erc-tls :server host
             :port 6697
             :nick user
             :password pwd)))
#+end_src


** Ledger

Control your finances with Ledger-cli.

Activate the =ledger-mode= to every file called =ledger=
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\ledger\\'" . ledger-mode))
#+end_src

Some queries/reports that I usually follow in my ledger
#+begin_src emacs-lisp
(setq
 ledger-reports
 '(("netcash" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^assets:bank ^assets:crypto liabilities:card")
   ("sports" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:sports")
   ("doctor" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:doctor")
   ("apartamento-mae" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:mother")
   ("apartamento-misce" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:misce")
   ("eas-profit" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --invert --current bal ^expenses:eval ^income:eval")
   ("food" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:food")
   ("donation" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:donation")
   ("apartamento-morumbi" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:house")
   ("creta" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:car:creta ^equity:car:creta")
   ("networth" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank liabilities equity:apartment")
   ("spent-vs-earned" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger bal -X BRL --period=\"last 4 weeks\" ^Expenses ^Income --invert -S amount")
   ("budget" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank:checking:budget liabilities:card")
   ("taxes" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^expenses:taxes")
   ("bal" "%(binary) -f %(ledger-file) bal")
   ("reg" "%(binary) -f %(ledger-file) reg")
   ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
   ("account" "%(binary) -f %(ledger-file) reg %(account)")))
#+end_src

*** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/copy-ledger-entry ()
  "Copy last ledger entry."
  (interactive)
  (save-excursion
    (backward-sentence)
    (let ((beg (point)))
      (forward-sentence)
      (kill-ring-save beg (point))))
  (yank))

(defun bk/clean-ledger ()
  "Bring back timeline structure to the whole file."
  (interactive)
  (if (eq major-mode 'ledger-mode)
      (let ((curr-line (line-number-at-pos)))
        (ledger-mode-clean-buffer)
        (line-move (- curr-line 1)))))
#+end_src

* Authentication

I rely on =auth-source= a lot to store my passwords. A =~/.authinfo.gpg= file is
a safe way to keep passwords stored for as long as you remember your GPG
password :')

The following piece of configuration was carefully crafted to be integrated with
MacOS key manager.

#+begin_src emacs-lisp
(require 'epa-file)
(require 'org-crypt)

(setq epg-gpg-program "gpg"
      org-tags-exclude-from-inheritance (quote ("crypt"))
      password-cache-expiry nil)

(after! auth-source
  (setq auth-sources (nreverse auth-sources)
        auth-source-cache-expiry nil
        auth-source-debug t))

(after! epa
  (set 'epg-pinentry-mode nil)
  (setq epa-file-encrypt-to '("wand@hey.com")))

(epa-file-enable)
(org-crypt-use-before-save-magic)
#+end_src

** Auxiliary functions

I also have a Bitwarden account to store things in the web. This function helps
me to get some useful data in the gpg file.

#+begin_src emacs-lisp
(defun bk/bitwarden ()
  "Get bitwarden."
  (interactive)
  (kill-new (auth-source-pick-first-password
             :host "bitwarden.app"
             :user "bartuka")))
#+end_src

* Patches

Sometimes I need to overwrite some implementation in a package.

** Doom

Overwrite the =load!= macro to consider GPG configuration files.
#+begin_src emacs-lisp
(defmacro load! (filename &optional path noerror)
  "Load a file relative to the current executing file (`load-file-name').

FILENAME is either a file path string or a form that should evaluate to such a
string at run time. PATH is where to look for the file (a string representing a
directory path). If omitted, the lookup is relative to either `load-file-name',
`byte-compile-current-file' or `buffer-file-name' (checked in that order).

If NOERROR is non-nil, don't throw an error if the file doesn't exist."
  (let* ((path (or path
                   (dir!)
                   (error "Could not detect path to look for '%s' in"
                          filename)))
         (file (if path
                   `(expand-file-name ,filename ,path)
                 filename)))
    `(if (string-match-p ".gpg$" ,file)
         (add-hook 'after-init-hook (lambda () (load-file ,file)))
       (condition-case-unless-debug e
           (let (file-name-handler-alist)
             (load ,file ,noerror 'nomessage))
         (doom-error (signal (car e) (cdr e)))
         (error (doom--handle-load-error e ,file ,path))))))
#+end_src

* Work

Every now and then I have to write some elisp code to help me in my work. I like
to keep them organized to keep at least some context to where/why the function
came to existence.

** App Sauce

First time I experimented with Git Worktrees in day to day work. Really liked
it. A git worktree + projectile + a dedicated clojure REPL connected == Great
experience!

#+begin_src emacs-lisp
(defun bk/create-worktree ()
  "Help development on multiple branches."
  (interactive)
  (let* ((root-proj (projectile-project-root))
         (proj-name (car (cdr (nreverse (split-string root-proj "/")))))
         (dest-dir (file-name-directory (directory-file-name root-proj)))
         (branch (ido-completing-read "Choose the branch: " (magit-list-local-branch-names)))
         (worktree-path (concat dest-dir proj-name "-wt-" branch)))
    (magit-worktree-checkout worktree-path branch)
    (projectile-find-file)))

(defun bk/delete-worktree ()
  "Delete worktree and all its open buffers."
  (interactive)
  (let ((worktree (ido-completing-read "Choose worktree: " (magit-list-worktrees))))
    (mapc (lambda (buffer)
            (with-current-buffer buffer
              (let ((worktree-name (file-name-base worktree)))
                (when (string-equal (projectile-project-name) worktree-name)
                  (kill-buffer buffer)))))
          (buffer-list))
    (projectile-remove-current-project-from-known-projects)
    (magit-worktree-delete worktree)))
#+end_src

** Reify Health

Basic functions to connect to Clojure REPL.
#+begin_src emacs-lisp
(defun reifyhealth/cider-connect ()
  "Connect into eSource."
  (interactive)
  (cider-connect-clj (list :host "localhost" :port 12344)))
#+end_src

Open my specific notes from work.
#+begin_src emacs-lisp
(defun reifyhealth ()
  "Open file notes from work."
  (interactive)
  (find-file "~/repos/reifyhealth/work.org"))
#+end_src

and we had to generate UUIDs to mock some tests every so often.
#+begin_src emacs-lisp
(defun bk/uuid ()
  "Create uuid and add to clipboard."
  (interactive)
  (kill-new (uuidgen-4)))
#+end_src

** Cisco

Good stuff.
#+begin_src emacs-lisp
(load! "+work-cisco.el.gpg")
#+end_src
