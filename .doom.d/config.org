#+TITLE: Emacs configuration
#+AUTHOR: Wanderson Ferreira
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: org-startup-folded: showall

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* Summary :TOC_2_gh:
- [[#appearance][Appearance]]
- [[#window][Window]]
  - [[#moving][Moving]]
  - [[#better-split][Better split]]
- [[#programming-languages][Programming Languages]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#java][Java]]
- [[#macos-specifics][MacOS specifics]]
  - [[#search-in-homebrew][Search in Homebrew]]
- [[#apps][Apps]]
  - [[#gif][Gif]]
  - [[#plantuml][PlantUML]]
  - [[#keyfreq][Keyfreq]]
  - [[#vlf][VLF]]
  - [[#irc][IRC]]
  - [[#ledger][Ledger]]
- [[#authentication][Authentication]]
  - [[#auxiliary-functions][Auxiliary functions]]
- [[#work][Work]]
  - [[#app-sauce][App Sauce]]
  - [[#reify-health][Reify Health]]
  - [[#cisco][Cisco]]

* Appearance

Doom comes with some nice themes. For now, I've been using Zenburn most of the
time.

#+begin_src emacs-lisp
(setq doom-theme 'doom-zenburn)
#+end_src

* Window

** Moving

Use shift arrows to move between windows.
#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src

However, Org mode requires a little workaround to make shift arrow movements to
work.
#+begin_src emacs-lisp
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src

** Better split

When you split the buffer in any direction, move the cursor there and show the
previous buffer.
#+begin_src emacs-lisp
(defun bk/vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun bk/hsplit-last-buffer ()
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))
#+end_src

Overwrite the default split bindings
#+begin_src emacs-lisp
(map! "C-x 2" #'bk/vsplit-last-buffer
      "C-x 3" #'bk/hsplit-last-buffer)
#+end_src

* Programming Languages

** Emacs Lisp

*** Appearance

I don't like the too colorful buffers. So, removing the rainbow delimiter mode.
#+begin_src emacs-lisp
(after! elisp-mode
  (remove-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode))
#+end_src

*** Taming Parenthesis

You will definitely hate Lisp if you don't understand structural editing.
#+begin_src emacs-lisp
(use-package! paredit
  :config
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode))
#+end_src

*** Test frameworks

Buttercup (Behavior Driven Emacs Lisp Testing) framework has one annoyance when
you run the test suite: it moves the cursor from the point to the end of the
test file. This =advice= is a workaround to keep the point where it was:
#+begin_src emacs-lisp
(use-package! buttercup
  :config
  (define-advice buttercup--run-suites (:around (orig-fun &rest args))
    "Keep the cursor at-point after running test suite with buttercup."
    (setq save-point (point))
    (unwind-protect
        (apply orig-fun args)
      (goto-char save-point))))
#+end_src

** Java
LSP is very good to develop in Java.

#+begin_src emacs-lisp
(use-package! lsp-java
  :init
  (setq lsp-java-format-settings-profile "GoogleStyle"
        lsp-java-format-settings-url "https://raw.githubusercontent.com/google/styleguide/gh-pages/eclipse-java-google-style.xml"
        lsp-java-save-actions-organize-imports t)
  :config
  (add-hook! 'java-mode-hook (electric-pair-mode +1))
  (add-hook! 'java-mode-hook (subword-mode +1)))
#+end_src

*** Appearance

No colorful window either
#+begin_src emacs-lisp
(after! cc-mode
  (remove-hook 'java-mode-hook #'rainbow-delimiters-mode))
#+end_src

* MacOS specifics

I prefer to change Command to =meta=.

#+begin_src emacs-lisp
(when IS-MAC
  (setq mac-command-modifier 'meta
        mac-option-modifier '(:ordinary super :button 2)))
#+end_src


** Search in Homebrew

Sometimes I need to verify if a package is available in homebrew or not. Making
the query from Emacs has been useful.

#+begin_src emacs-lisp
(defun bk/brew-search ()
  "Search homebrew for a file to be installed."
  (interactive "")
  (let* ((query (read-string "Search in Homebrew: "))
         (res (shell-command-to-string
               (format "brew search %s" query)))
         (res-list (-> res
                       (split-string "==> Formulae")
                       (-second-item)
                       (string-trim)
                       (split-string "\n")))
         (to-be-installed
          (completing-read
           "Install one of the packages: "
           res-list)))
    (when (not (string-empty-p to-be-installed))
      (async-shell-command
       (format "brew install %s" to-be-installed)))))
#+end_src

* Apps

I'm not sure how to classify something as an "app" inside Emacs. Perhaps they
are heavily dependent of external tools?

To be honest, most things in this section are here because I don't know a better
place to put it.

** Gif

I need to show off some Emacs work or feature and be able to record a small GIF
in seconds is perfect. During the development of my Emacs packages I've been
recording GIFs to reproduce feature behaviors to new users a lot.

#+begin_src emacs-lisp
(use-package! gif-screencast
  :config
  (setq gif-screencast-args '("-x")
        gif-screencast-cropping-program "mogrify"
        gif-screencast-capture-format "ppm"))
#+end_src


** PlantUML

Drawing diagrams to put some form to your system design ideas? Yeap!

#+begin_src emacs-lisp
(use-package! plantuml-mode
  :config
  (setq plantuml-jar-path "~/dotfiles/plantuml.jar"))
#+end_src


** Keyfreq

Important to monitor your key usage in order to improve your editing skills in
the long run. More tips [[https://github.com/wandersoncferreira/vim-mindset-apply-emacs#general-tips][here]].

#+begin_src emacs-lisp
(use-package! keyfreq
  :init
  (setq keyfreq-excluded-commands
        '(self-insert-command))
  :config
  (keyfreq-mode +1)
  (keyfreq-autosave-mode +1))
#+end_src


** VLF

Help opening very large files.

#+begin_src emacs-lisp
(use-package! vlf
  :config
  (require 'vlf-setup)
  (custom-set-variables
   '(vlf-application 'dont-ask)))
#+end_src


** IRC

I like to communicate like its the 70's again.

#+begin_src emacs-lisp
(require 'erc)
(require 'erc-track)

(setq erc-server "irc.libera.chat"
      erc-nick "bartuka"
      erc-user-full-name "Wanderson Ferreira"
      erc-track-shorten-start 8
      erc-kill-buffer-on-part t
      erc-auto-query 'bury
      erc-prompt-for-password nil)

(erc-autojoin-mode +1)
(setq erc-autojoin-channels-alist
      '(("irc.libera.chat" "#emacs" "#systemcrafters" "#code-review-emacs"))
      erc-autojoin-timing :ident
      erc-autojoin-delay 30
      erc-join-buffer 'bury)

(erc-track-mode +1)
(setq erc-keywords '("code-review" "emacs" "clojure")
      erc-track-exclude-server-buffer t
      erc-track-exclude-types '("JOIN" "PART" "QUIT" "NICK" "MODE")
      erc-track-use-faces t
      erc-track-faces-priority-list
      '(erc-current-nick-face
        erc-keyword-face
        erc-direct-msg-face)
      erc-track-priority-faces-only 'all)
#+end_src

*** Twitch IRC

I learned it was possible to connect to a Twitch chat via IRC>
#+begin_src emacs-lisp
(defun twitch-start-irc ()
  "Connect to Twitch IRC.
Get an oauth token from this website https://twitchapps.com/tmi/."
  (interactive)
  (let* ((host "irc.chat.twitch.tv")
         (user "bartuka_")
         (pwd (auth-source-pick-first-password
               :host host
               :user user)))
    (erc-tls :server host
             :port 6697
             :nick user
             :password pwd)))
#+end_src


** Ledger

Control your finances with Ledger-cli.

Activate the =ledger-mode= to every file called =ledger=
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\ledger\\'" . ledger-mode))
#+end_src

Some queries/reports that I usually follow in my ledger
#+begin_src emacs-lisp
(setq
 ledger-reports
 '(("netcash" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^assets:bank ^assets:crypto liabilities:card")
   ("sports" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:sports")
   ("doctor" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:doctor")
   ("apartamento-mae" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:mother")
   ("apartamento-misce" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ -S date --current -w reg ^liabilities:apartment:misce")
   ("eas-profit" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --invert --current bal ^expenses:eval ^income:eval")
   ("food" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:food")
   ("donation" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:donation")
   ("apartamento-morumbi" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:house")
   ("creta" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^expenses:car:creta ^equity:car:creta")
   ("networth" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank liabilities equity:apartment")
   ("spent-vs-earned" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger bal -X BRL --period=\"last 4 weeks\" ^Expenses ^Income --invert -S amount")
   ("budget" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -X R$ --current bal ^assets:bank:checking:budget liabilities:card")
   ("taxes" "ledger [[ledger-mode-flags]] -f /Users/wferreir/ledger -R -X R$ --current bal ^expenses:taxes")
   ("bal" "%(binary) -f %(ledger-file) bal")
   ("reg" "%(binary) -f %(ledger-file) reg")
   ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
   ("account" "%(binary) -f %(ledger-file) reg %(account)")))
#+end_src

*** Auxiliary Functions

#+begin_src emacs-lisp
(defun bk/copy-ledger-entry ()
  "Copy last ledger entry."
  (interactive)
  (save-excursion
    (backward-sentence)
    (let ((beg (point)))
      (forward-sentence)
      (kill-ring-save beg (point))))
  (yank))

(defun bk/clean-ledger ()
  "Bring back timeline structure to the whole file."
  (interactive)
  (if (eq major-mode 'ledger-mode)
      (let ((curr-line (line-number-at-pos)))
        (ledger-mode-clean-buffer)
        (line-move (- curr-line 1)))))
#+end_src

* Authentication

I rely on =auth-source= a lot to store my passwords. A =~/.authinfo.gpg= file is
a safe way to keep passwords stored for as long as you remember your GPG
password :')

The following piece of configuration was carefully crafted to be integrated with
MacOS key manager.

#+begin_src emacs-lisp
(require 'epa-file)
(require 'org-crypt)

(setq epg-gpg-program "gpg"
      org-tags-exclude-from-inheritance (quote ("crypt"))
      password-cache-expiry nil)

(after! auth-source
  (setq auth-sources (nreverse auth-sources)
        auth-source-cache-expiry nil
        auth-source-debug t))

(after! epa
  (set 'epg-pinentry-mode nil)
  (setq epa-file-encrypt-to '("wand@hey.com")))

(epa-file-enable)
(org-crypt-use-before-save-magic)
#+end_src

** Auxiliary functions

I also have a Bitwarden account to store things in the web. This function helps
me to get some useful data in the gpg file.

#+begin_src emacs-lisp
(defun bk/bitwarden ()
  "Get bitwarden."
  (interactive)
  (kill-new (auth-source-pick-first-password
             :host "bitwarden.app"
             :user "bartuka")))
#+end_src

* Work

Every now and then I have to write some elisp code to help me in my work. I like
to keep them organized to keep at least some context to where/why the function
came to existence.

** App Sauce

First time I experimented with Git Worktrees in day to day work. Really liked
it. A git worktree + projectile + a dedicated clojure REPL connected == Great
experience!

#+begin_src emacs-lisp
(defun bk/create-worktree ()
  "Help development on multiple branches."
  (interactive)
  (let* ((root-proj (projectile-project-root))
         (proj-name (car (cdr (nreverse (split-string root-proj "/")))))
         (dest-dir (file-name-directory (directory-file-name root-proj)))
         (branch (ido-completing-read "Choose the branch: " (magit-list-local-branch-names)))
         (worktree-path (concat dest-dir proj-name "-wt-" branch)))
    (magit-worktree-checkout worktree-path branch)
    (projectile-find-file)))

(defun bk/delete-worktree ()
  "Delete worktree and all its open buffers."
  (interactive)
  (let ((worktree (ido-completing-read "Choose worktree: " (magit-list-worktrees))))
    (mapc (lambda (buffer)
            (with-current-buffer buffer
              (let ((worktree-name (file-name-base worktree)))
                (when (string-equal (projectile-project-name) worktree-name)
                  (kill-buffer buffer)))))
          (buffer-list))
    (projectile-remove-current-project-from-known-projects)
    (magit-worktree-delete worktree)))
#+end_src

** Reify Health

Basic functions to connect to Clojure REPL.
#+begin_src emacs-lisp
(defun reifyhealth/cider-connect ()
  "Connect into eSource."
  (interactive)
  (cider-connect-clj (list :host "localhost" :port 12344)))
#+end_src

Open my specific notes from work.
#+begin_src emacs-lisp
(defun reifyhealth ()
  "Open file notes from work."
  (interactive)
  (find-file "~/repos/reifyhealth/work.org"))
#+end_src

and we had to generate UUIDs to mock some tests every so often.
#+begin_src emacs-lisp
(defun bk/uuid ()
  "Create uuid and add to clipboard."
  (interactive)
  (kill-new (uuidgen-4)))
#+end_src

** Cisco
